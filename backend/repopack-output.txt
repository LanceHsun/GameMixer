This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repopack on: 2025-01-29T04:06:02.347Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repopack, visit: https://github.com/yamadashy/repopack

================================================================
Repository Structure
================================================================
.wrangler/
  tmp/
    bundle-KqtDRJ/
      checked-fetch.js
      middleware-insertion-facade.js
      middleware-loader.entry.ts
    dev-vSRgYD/
      index.js
      index.js.map
config/
  multer.js
controllers/
  eventController.js
models/
  Event.js
routes/
  events.js
src/
  config/
    cloudflare.js
  controllers/
    eventController.js
  index.js
  schema.sql
tests/
  helpers/
    fileHelper.js
  events.test.js
  setup.js
.env.development
.gitignore
jest.config.js
package.json
server.js
wrangler.toml

================================================================
Repository Files
================================================================

================
File: .wrangler/tmp/bundle-KqtDRJ/checked-fetch.js
================
const urls = new Set();

function checkURL(request, init) {
	const url =
		request instanceof URL
			? request
			: new URL(
					(typeof request === "string"
						? new Request(request, init)
						: request
					).url
				);
	if (url.port && url.port !== "443" && url.protocol === "https:") {
		if (!urls.has(url.toString())) {
			urls.add(url.toString());
			console.warn(
				`WARNING: known issue with \`fetch()\` requests to custom HTTPS ports in published Workers:\n` +
					` - ${url.toString()} - the custom port will be ignored when the Worker is published using the \`wrangler deploy\` command.\n`
			);
		}
	}
}

globalThis.fetch = new Proxy(globalThis.fetch, {
	apply(target, thisArg, argArray) {
		const [request, init] = argArray;
		checkURL(request, init);
		return Reflect.apply(target, thisArg, argArray);
	},
});

================
File: .wrangler/tmp/bundle-KqtDRJ/middleware-insertion-facade.js
================
import worker, * as OTHER_EXPORTS from "/Users/lancelin/03CS/program/game-mixer/backend/src/index.js";
				import * as __MIDDLEWARE_0__ from "/Users/lancelin/03CS/program/game-mixer/backend/node_modules/wrangler/templates/middleware/middleware-ensure-req-body-drained.ts";
import * as __MIDDLEWARE_1__ from "/Users/lancelin/03CS/program/game-mixer/backend/node_modules/wrangler/templates/middleware/middleware-miniflare3-json-error.ts";

				export * from "/Users/lancelin/03CS/program/game-mixer/backend/src/index.js";

				export const __INTERNAL_WRANGLER_MIDDLEWARE__ = [
					
					__MIDDLEWARE_0__.default,__MIDDLEWARE_1__.default
				]
				export default worker;

================
File: .wrangler/tmp/bundle-KqtDRJ/middleware-loader.entry.ts
================
// This loads all middlewares exposed on the middleware object and then starts
// the invocation chain. The big idea is that we can add these to the middleware
// export dynamically through wrangler, or we can potentially let users directly
// add them as a sort of "plugin" system.

import ENTRY, { __INTERNAL_WRANGLER_MIDDLEWARE__ } from "/Users/lancelin/03CS/program/game-mixer/backend/.wrangler/tmp/bundle-KqtDRJ/middleware-insertion-facade.js";
import { __facade_invoke__, __facade_register__, Dispatcher } from "/Users/lancelin/03CS/program/game-mixer/backend/node_modules/wrangler/templates/middleware/common.ts";
import type { WorkerEntrypointConstructor } from "/Users/lancelin/03CS/program/game-mixer/backend/.wrangler/tmp/bundle-KqtDRJ/middleware-insertion-facade.js";

// Preserve all the exports from the worker
export * from "/Users/lancelin/03CS/program/game-mixer/backend/.wrangler/tmp/bundle-KqtDRJ/middleware-insertion-facade.js";

class __Facade_ScheduledController__ implements ScheduledController {
	readonly #noRetry: ScheduledController["noRetry"];

	constructor(
		readonly scheduledTime: number,
		readonly cron: string,
		noRetry: ScheduledController["noRetry"]
	) {
		this.#noRetry = noRetry;
	}

	noRetry() {
		if (!(this instanceof __Facade_ScheduledController__)) {
			throw new TypeError("Illegal invocation");
		}
		// Need to call native method immediately in case uncaught error thrown
		this.#noRetry();
	}
}

function wrapExportedHandler(worker: ExportedHandler): ExportedHandler {
	// If we don't have any middleware defined, just return the handler as is
	if (
		__INTERNAL_WRANGLER_MIDDLEWARE__ === undefined ||
		__INTERNAL_WRANGLER_MIDDLEWARE__.length === 0
	) {
		return worker;
	}
	// Otherwise, register all middleware once
	for (const middleware of __INTERNAL_WRANGLER_MIDDLEWARE__) {
		__facade_register__(middleware);
	}

	const fetchDispatcher: ExportedHandlerFetchHandler = function (
		request,
		env,
		ctx
	) {
		if (worker.fetch === undefined) {
			throw new Error("Handler does not export a fetch() function.");
		}
		return worker.fetch(request, env, ctx);
	};

	return {
		...worker,
		fetch(request, env, ctx) {
			const dispatcher: Dispatcher = function (type, init) {
				if (type === "scheduled" && worker.scheduled !== undefined) {
					const controller = new __Facade_ScheduledController__(
						Date.now(),
						init.cron ?? "",
						() => {}
					);
					return worker.scheduled(controller, env, ctx);
				}
			};
			return __facade_invoke__(request, env, ctx, dispatcher, fetchDispatcher);
		},
	};
}

function wrapWorkerEntrypoint(
	klass: WorkerEntrypointConstructor
): WorkerEntrypointConstructor {
	// If we don't have any middleware defined, just return the handler as is
	if (
		__INTERNAL_WRANGLER_MIDDLEWARE__ === undefined ||
		__INTERNAL_WRANGLER_MIDDLEWARE__.length === 0
	) {
		return klass;
	}
	// Otherwise, register all middleware once
	for (const middleware of __INTERNAL_WRANGLER_MIDDLEWARE__) {
		__facade_register__(middleware);
	}

	// `extend`ing `klass` here so other RPC methods remain callable
	return class extends klass {
		#fetchDispatcher: ExportedHandlerFetchHandler<Record<string, unknown>> = (
			request,
			env,
			ctx
		) => {
			this.env = env;
			this.ctx = ctx;
			if (super.fetch === undefined) {
				throw new Error("Entrypoint class does not define a fetch() function.");
			}
			return super.fetch(request);
		};

		#dispatcher: Dispatcher = (type, init) => {
			if (type === "scheduled" && super.scheduled !== undefined) {
				const controller = new __Facade_ScheduledController__(
					Date.now(),
					init.cron ?? "",
					() => {}
				);
				return super.scheduled(controller);
			}
		};

		fetch(request: Request<unknown, IncomingRequestCfProperties>) {
			return __facade_invoke__(
				request,
				this.env,
				this.ctx,
				this.#dispatcher,
				this.#fetchDispatcher
			);
		}
	};
}

let WRAPPED_ENTRY: ExportedHandler | WorkerEntrypointConstructor | undefined;
if (typeof ENTRY === "object") {
	WRAPPED_ENTRY = wrapExportedHandler(ENTRY);
} else if (typeof ENTRY === "function") {
	WRAPPED_ENTRY = wrapWorkerEntrypoint(ENTRY);
}
export default WRAPPED_ENTRY;

================
File: .wrangler/tmp/dev-vSRgYD/index.js
================
var __defProp = Object.defineProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });

// .wrangler/tmp/bundle-KqtDRJ/checked-fetch.js
var urls = /* @__PURE__ */ new Set();
function checkURL(request, init) {
  const url = request instanceof URL ? request : new URL(
    (typeof request === "string" ? new Request(request, init) : request).url
  );
  if (url.port && url.port !== "443" && url.protocol === "https:") {
    if (!urls.has(url.toString())) {
      urls.add(url.toString());
      console.warn(
        `WARNING: known issue with \`fetch()\` requests to custom HTTPS ports in published Workers:
 - ${url.toString()} - the custom port will be ignored when the Worker is published using the \`wrangler deploy\` command.
`
      );
    }
  }
}
__name(checkURL, "checkURL");
globalThis.fetch = new Proxy(globalThis.fetch, {
  apply(target, thisArg, argArray) {
    const [request, init] = argArray;
    checkURL(request, init);
    return Reflect.apply(target, thisArg, argArray);
  }
});

// node_modules/itty-router/index.mjs
var e = /* @__PURE__ */ __name(({ base: e2 = "", routes: t = [], ...o2 } = {}) => ({ __proto__: new Proxy({}, { get: (o3, s2, r, n) => "handle" == s2 ? r.fetch : (o4, ...a) => t.push([s2.toUpperCase?.(), RegExp(`^${(n = (e2 + o4).replace(/\/+(\/|$)/g, "$1")).replace(/(\/?\.?):(\w+)\+/g, "($1(?<$2>*))").replace(/(\/?\.?):(\w+)/g, "($1(?<$2>[^$1/]+?))").replace(/\./g, "\\.").replace(/(\/?)\*/g, "($1.*)?")}/*$`), a, n]) && r }), routes: t, ...o2, async fetch(e3, ...o3) {
  let s2, r, n = new URL(e3.url), a = e3.query = { __proto__: null };
  for (let [e4, t2] of n.searchParams)
    a[e4] = a[e4] ? [].concat(a[e4], t2) : t2;
  for (let [a2, c2, i2, l2] of t)
    if ((a2 == e3.method || "ALL" == a2) && (r = n.pathname.match(c2))) {
      e3.params = r.groups || {}, e3.route = l2;
      for (let t2 of i2)
        if (null != (s2 = await t2(e3.proxy ?? e3, ...o3)))
          return s2;
    }
} }), "e");
var o = /* @__PURE__ */ __name((e2 = "text/plain; charset=utf-8", t) => (o2, { headers: s2 = {}, ...r } = {}) => void 0 === o2 || "Response" === o2?.constructor.name ? o2 : new Response(t ? t(o2) : o2, { headers: { "content-type": e2, ...s2.entries ? Object.fromEntries(s2) : s2 }, ...r }), "o");
var s = o("application/json; charset=utf-8", JSON.stringify);
var c = o("text/plain; charset=utf-8", String);
var i = o("text/html");
var l = o("image/jpeg");
var p = o("image/png");
var d = o("image/webp");

// src/config/cloudflare.js
async function uploadToCloudflareImages(buffer, metadata = {}, accountId, apiToken) {
  const formData = new FormData();
  formData.append("file", new Blob([buffer]));
  if (metadata) {
    formData.append("metadata", JSON.stringify(metadata));
  }
  const response = await fetch(
    `https://api.cloudflare.com/client/v4/accounts/${accountId}/images/v1`,
    {
      method: "POST",
      headers: {
        "Authorization": `Bearer ${apiToken}`
      },
      body: formData
    }
  );
  const result = await response.json();
  if (!result.success) {
    throw new Error(result.errors[0].message);
  }
  return {
    id: result.result.id,
    url: result.result.variants[0]
  };
}
__name(uploadToCloudflareImages, "uploadToCloudflareImages");
async function uploadToCloudflareStream(buffer, metadata = {}, accountId, apiToken) {
  const response = await fetch(
    `https://api.cloudflare.com/client/v4/accounts/${accountId}/stream`,
    {
      method: "POST",
      headers: {
        "Authorization": `Bearer ${apiToken}`
      },
      body: buffer
    }
  );
  const result = await response.json();
  if (!result.success) {
    throw new Error(result.errors[0].message);
  }
  return {
    id: result.result.uid,
    url: `https://watch.cloudflarestream.com/${result.result.uid}`
  };
}
__name(uploadToCloudflareStream, "uploadToCloudflareStream");
async function deleteCloudflareImage(imageId, accountId, apiToken) {
  const response = await fetch(
    `https://api.cloudflare.com/client/v4/accounts/${accountId}/images/v1/${imageId}`,
    {
      method: "DELETE",
      headers: {
        "Authorization": `Bearer ${apiToken}`
      }
    }
  );
  const result = await response.json();
  if (!result.success) {
    throw new Error(result.errors[0].message);
  }
}
__name(deleteCloudflareImage, "deleteCloudflareImage");
async function deleteCloudflareVideo(videoId2, accountId, apiToken) {
  const response = await fetch(
    `https://api.cloudflare.com/client/v4/accounts/${accountId}/stream/${videoId2}`,
    {
      method: "DELETE",
      headers: {
        "Authorization": `Bearer ${apiToken}`
      }
    }
  );
  const result = await response.json();
  if (!result.success) {
    throw new Error(result.errors[0].message);
  }
}
__name(deleteCloudflareVideo, "deleteCloudflareVideo");

// src/controllers/eventController.js
var EventController = class {
  async createEvent(req, env) {
    try {
      console.log("Starting createEvent");
      console.log("Account ID:", env.CLOUDFLARE_ACCOUNT_ID);
      console.log("API Token length:", env.CLOUDFLARE_API_TOKEN?.length);
      console.log("API Token first 10 chars:", env.CLOUDFLARE_API_TOKEN?.substring(0, 10));
      console.log("CLOUDFLARE_ACCOUNT_ID:", env.CLOUDFLARE_ACCOUNT_ID);
      console.log("API Token exists:", !!env.CLOUDFLARE_API_TOKEN);
      const formData = await req.formData();
      const eventData = JSON.parse(formData.get("data"));
      const eventId = crypto.randomUUID();
      let videoId2 = null;
      let videoUrl = null;
      const videoFile = formData.get("video");
      console.log("Video file exists:", !!videoFile);
      console.log("Video file size:", videoFile?.size);
      if (videoFile && videoFile.size > 0) {
        const videoBuffer = await videoFile.arrayBuffer();
        const videoResult = await uploadToCloudflareStream(
          videoBuffer,
          { eventId },
          env.CLOUDFLARE_ACCOUNT_ID,
          env.CLOUDFLARE_API_TOKEN
        );
        videoId2 = videoResult.id;
        videoUrl = videoResult.url;
      }
      const images2 = [];
      for (const [key, value] of formData.entries()) {
        if (key === "images" && value.size > 0) {
          const imageBuffer = await value.arrayBuffer();
          const imageResult = await uploadToCloudflareImages(
            imageBuffer,
            { eventId },
            env.CLOUDFLARE_ACCOUNT_ID,
            env.CLOUDFLARE_API_TOKEN
          );
          images2.push({
            id: crypto.randomUUID(),
            image_id: imageResult.id,
            url: imageResult.url
          });
        }
      }
      await env.DB.batch([
        env.DB.prepare(`
            INSERT INTO events (
              id, title, time_start, time_end, 
              description_content, description_format,
              video_id, video_url,
              created_at, updated_at
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
          `).bind(
          eventId,
          eventData.title,
          eventData.time.start,
          eventData.time.end,
          eventData.description.content,
          eventData.description.format,
          videoId2,
          videoUrl
        ),
        // Insert image data
        ...images2.map(
          (img) => env.DB.prepare(`
              INSERT INTO event_images (id, event_id, image_id, url) 
              VALUES (?, ?, ?, ?)
            `).bind(img.id, eventId, img.image_id, img.url)
        ),
        // Insert link data
        ...(eventData.links || []).map(
          (link) => env.DB.prepare(`
              INSERT INTO event_links (id, event_id, type, description, url)
              VALUES (?, ?, ?, ?, ?)
            `).bind(crypto.randomUUID(), eventId, link.type, link.description, link.url)
        ),
        // Insert tag data
        ...(eventData.tags || []).map(
          (tag) => env.DB.prepare(`
              INSERT INTO event_tags (event_id, tag)
              VALUES (?, ?)
            `).bind(eventId, tag)
        )
      ]);
      const event = await this.getEventById(env.DB, eventId);
      return Response.json({
        success: true,
        data: event
      }, { status: 201 });
    } catch (error) {
      console.error("Error in createEvent:", error);
      try {
        if (typeof videoId !== "undefined" && videoId) {
          await deleteCloudflareVideo(videoId, env.CLOUDFLARE_ACCOUNT_ID, env.CLOUDFLARE_API_TOKEN);
        }
        if (typeof images !== "undefined" && images?.length > 0) {
          await Promise.all(images.map(
            (img) => deleteCloudflareImage(img.image_id, env.CLOUDFLARE_ACCOUNT_ID, env.CLOUDFLARE_API_TOKEN)
          ));
        }
      } catch (cleanupError) {
        console.error("Error during cleanup:", cleanupError);
      }
      return Response.json({
        success: false,
        error: error.message
      }, { status: 400 });
    }
  }
  async getEvents(req, env) {
    try {
      const url = new URL(req.url);
      const tags = url.searchParams.get("tags");
      let query = `
          SELECT 
            e.*,
            json_group_array(DISTINCT json_object(
              'id', ei.id,
              'url', ei.url
            )) as images,
            json_group_array(DISTINCT et.tag) as tags,
            json_group_array(DISTINCT json_object(
              'type', el.type,
              'description', el.description,
              'url', el.url
            )) as links
          FROM events e
          LEFT JOIN event_images ei ON e.id = ei.event_id
          LEFT JOIN event_tags et ON e.id = et.event_id
          LEFT JOIN event_links el ON e.id = el.event_id
        `;
      const params = [];
      if (tags) {
        query += `
            WHERE e.id IN (
              SELECT event_id 
              FROM event_tags 
              WHERE tag IN (${tags.split(",").map(() => "?").join(",")})
              GROUP BY event_id
              HAVING COUNT(DISTINCT tag) = ?
            )
          `;
        params.push(...tags.split(","), tags.split(",").length);
      }
      query += " GROUP BY e.id ORDER BY e.created_at DESC";
      const events = await env.DB.prepare(query).bind(...params).all();
      return Response.json({
        success: true,
        data: events.results.map((event) => ({
          ...event,
          images: JSON.parse(event.images),
          tags: JSON.parse(event.tags),
          links: JSON.parse(event.links)
        }))
      });
    } catch (error) {
      console.error("Error in getEvents:", error);
      return Response.json({
        success: false,
        error: error.message
      }, { status: 400 });
    }
  }
  async getEvent(req, env) {
    try {
      const { id } = req.params;
      const event = await this.getEventById(env.DB, id);
      if (!event) {
        return Response.json({
          success: false,
          error: "Event not found"
        }, { status: 404 });
      }
      return Response.json({
        success: true,
        data: event
      });
    } catch (error) {
      console.error("Error in getEvent:", error);
      return Response.json({
        success: false,
        error: error.message
      }, { status: 400 });
    }
  }
  async updateEvent(req, env) {
    try {
      const { id } = req.params;
      const formData = await req.formData();
      const eventData = JSON.parse(formData.get("data"));
      const event = await this.getEventById(env.DB, id);
      if (!event) {
        return Response.json({
          success: false,
          error: "Event not found"
        }, { status: 404 });
      }
      let videoId2 = event.video_id;
      let videoUrl = event.video_url;
      const videoFile = formData.get("video");
      if (videoFile && videoFile.size > 0) {
        if (event.video_id) {
          await deleteCloudflareVideo(event.video_id, env.CLOUDFLARE_ACCOUNT_ID, env.CLOUDFLARE_API_TOKEN);
        }
        const videoBuffer = await videoFile.arrayBuffer();
        const videoResult = await uploadToCloudflareStream(
          videoBuffer,
          { eventId: event.id },
          env.CLOUDFLARE_ACCOUNT_ID,
          env.CLOUDFLARE_API_TOKEN
        );
        videoId2 = videoResult.id;
        videoUrl = videoResult.url;
      }
      let newImages = [];
      let hasNewImages = false;
      for (const [key, value] of formData.entries()) {
        if (key === "images" && value.size > 0) {
          hasNewImages = true;
          const imageBuffer = await value.arrayBuffer();
          const imageResult = await uploadToCloudflareImages(
            imageBuffer,
            { eventId: event.id },
            env.CLOUDFLARE_ACCOUNT_ID,
            env.CLOUDFLARE_API_TOKEN
          );
          newImages.push({
            id: crypto.randomUUID(),
            image_id: imageResult.id,
            url: imageResult.url
          });
        }
      }
      if (hasNewImages && event.images) {
        await Promise.all(
          event.images.map(
            (img) => deleteCloudflareImage(img.image_id, env.CLOUDFLARE_ACCOUNT_ID, env.CLOUDFLARE_API_TOKEN)
          )
        );
      }
      await env.DB.batch([
        env.DB.prepare(`
            UPDATE events 
            SET title = ?, time_start = ?, time_end = ?, 
                description_content = ?, description_format = ?,
                video_id = ?, video_url = ?,
                updated_at = CURRENT_TIMESTAMP
            WHERE id = ?
          `).bind(
          eventData.title,
          eventData.time.start,
          eventData.time.end,
          eventData.description.content,
          eventData.description.format,
          videoId2,
          videoUrl,
          event.id
        ),
        // Delete old related data
        env.DB.prepare("DELETE FROM event_images WHERE event_id = ?").bind(event.id),
        env.DB.prepare("DELETE FROM event_links WHERE event_id = ?").bind(event.id),
        env.DB.prepare("DELETE FROM event_tags WHERE event_id = ?").bind(event.id),
        // Insert new image data
        ...newImages.map(
          (img) => env.DB.prepare(`
              INSERT INTO event_images (id, event_id, image_id, url)
              VALUES (?, ?, ?, ?)
            `).bind(img.id, event.id, img.image_id, img.url)
        ),
        // Insert new link data
        ...(eventData.links || []).map(
          (link) => env.DB.prepare(`
              INSERT INTO event_links (id, event_id, type, description, url)
              VALUES (?, ?, ?, ?, ?)
            `).bind(crypto.randomUUID(), event.id, link.type, link.description, link.url)
        ),
        // Insert new tag data
        ...(eventData.tags || []).map(
          (tag) => env.DB.prepare(`
              INSERT INTO event_tags (event_id, tag)
              VALUES (?, ?)
            `).bind(event.id, tag)
        )
      ]);
      const updatedEvent = await this.getEventById(env.DB, event.id);
      return Response.json({
        success: true,
        data: updatedEvent
      });
    } catch (error) {
      console.error("Error in updateEvent:", error);
      return Response.json({
        success: false,
        error: error.message
      }, { status: 400 });
    }
  }
  async deleteEvent(req, env) {
    try {
      const { id } = req.params;
      const event = await this.getEventById(env.DB, id);
      if (!event) {
        return Response.json({
          success: false,
          error: "Event not found"
        }, { status: 404 });
      }
      if (event.video_id) {
        await deleteCloudflareVideo(event.video_id, env.CLOUDFLARE_ACCOUNT_ID, env.CLOUDFLARE_API_TOKEN);
      }
      if (event.images && event.images.length > 0) {
        await Promise.all(
          event.images.map(
            (img) => deleteCloudflareImage(img.image_id, env.CLOUDFLARE_ACCOUNT_ID, env.CLOUDFLARE_API_TOKEN)
          )
        );
      }
      await env.DB.prepare("DELETE FROM events WHERE id = ?").bind(event.id).run();
      return Response.json({
        success: true,
        data: {}
      });
    } catch (error) {
      console.error("Error in deleteEvent:", error);
      return Response.json({
        success: false,
        error: error.message
      }, { status: 400 });
    }
  }
  // Helper function: Get complete event data
  async getEventById(db, eventId) {
    const query = `
        SELECT 
          e.*,
          json_group_array(DISTINCT json_object(
            'id', ei.id,
            'image_id', ei.image_id,
            'url', ei.url
          )) as images,
          json_group_array(DISTINCT et.tag) as tags,
          json_group_array(DISTINCT json_object(
            'type', el.type,
            'description', el.description,
            'url', el.url
          )) as links
        FROM events e
        LEFT JOIN event_images ei ON e.id = ei.event_id
        LEFT JOIN event_tags et ON e.id = et.event_id
        LEFT JOIN event_links el ON e.id = el.event_id
        WHERE e.id = ?
        GROUP BY e.id
      `;
    const result = await db.prepare(query).bind(eventId).first();
    if (!result)
      return null;
    return {
      ...result,
      images: JSON.parse(result.images),
      tags: JSON.parse(result.tags),
      links: JSON.parse(result.links)
    };
  }
};
__name(EventController, "EventController");
var eventController_default = new EventController();

// src/index.js
var router = e({ base: "/" });
var corsHeaders = {
  "Access-Control-Allow-Origin": "*",
  "Access-Control-Allow-Methods": "GET, POST, PUT, DELETE, OPTIONS",
  "Access-Control-Allow-Headers": "Content-Type, Authorization"
};
function addCorsHeaders(response) {
  const newHeaders = new Headers(response.headers);
  Object.entries(corsHeaders).forEach(([key, value]) => {
    newHeaders.set(key, value);
  });
  return new Response(response.body, {
    status: response.status,
    statusText: response.statusText,
    headers: newHeaders
  });
}
__name(addCorsHeaders, "addCorsHeaders");
router.get("/api/check-auth", async (request, env) => {
  try {
    const testResponse = await fetch(
      `https://api.cloudflare.com/client/v4/accounts/${env.CLOUDFLARE_ACCOUNT_ID}/images/v1/direct_upload`,
      {
        method: "POST",
        headers: {
          "Authorization": `Bearer ${env.CLOUDFLARE_API_TOKEN}`
        }
      }
    );
    const result = await testResponse.json();
    return Response.json({
      success: true,
      account_id: env.CLOUDFLARE_ACCOUNT_ID,
      token_exists: !!env.CLOUDFLARE_API_TOKEN,
      can_upload: result.success,
      details: result
    });
  } catch (error) {
    return Response.json({
      success: false,
      error: error.message,
      account_id: env.CLOUDFLARE_ACCOUNT_ID,
      token_exists: !!env.CLOUDFLARE_API_TOKEN
    });
  }
}).post("/api/test-image-upload", async (request, env) => {
  try {
    const formData = await request.formData();
    const imageFile = formData.get("image");
    if (!imageFile) {
      throw new Error("No image file provided");
    }
    const imageBuffer = await imageFile.arrayBuffer();
    const uploadFormData = new FormData();
    uploadFormData.append("file", new Blob([imageBuffer]));
    const response = await fetch(
      `https://api.cloudflare.com/client/v4/accounts/${env.CLOUDFLARE_ACCOUNT_ID}/images/v1`,
      {
        method: "POST",
        headers: {
          "Authorization": `Bearer ${env.CLOUDFLARE_API_TOKEN}`
        },
        body: uploadFormData
      }
    );
    const result = await response.json();
    return Response.json({
      success: true,
      upload_result: result
    });
  } catch (error) {
    return Response.json({
      success: false,
      error: error.message
    }, { status: 400 });
  }
}).get("/api/events", async (request, env) => addCorsHeaders(await eventController_default.getEvents(request, env))).get("/api/events/:id", async (request, env) => addCorsHeaders(await eventController_default.getEvent(request, env))).post("/api/events", async (request, env) => addCorsHeaders(await eventController_default.createEvent(request, env))).put("/api/events/:id", async (request, env) => addCorsHeaders(await eventController_default.updateEvent(request, env))).delete("/api/events/:id", async (request, env) => addCorsHeaders(await eventController_default.deleteEvent(request, env))).options("*", () => new Response(null, { headers: corsHeaders })).all("*", () => new Response("Not Found", { status: 404, headers: corsHeaders }));
var handleErrors = /* @__PURE__ */ __name((fn) => async (request, env, ctx) => {
  try {
    const response = await fn(request, env, ctx);
    return response;
  } catch (err) {
    console.error(err);
    return new Response(
      JSON.stringify({
        success: false,
        error: err.message || "Internal Server Error"
      }),
      {
        status: 500,
        headers: {
          "Content-Type": "application/json",
          ...corsHeaders
        }
      }
    );
  }
}, "handleErrors");
var src_default = {
  fetch: handleErrors(async (request, env, ctx) => {
    return router.handle(request, env, ctx);
  })
};

// node_modules/wrangler/templates/middleware/middleware-ensure-req-body-drained.ts
var drainBody = /* @__PURE__ */ __name(async (request, env, _ctx, middlewareCtx) => {
  try {
    return await middlewareCtx.next(request, env);
  } finally {
    try {
      if (request.body !== null && !request.bodyUsed) {
        const reader = request.body.getReader();
        while (!(await reader.read()).done) {
        }
      }
    } catch (e2) {
      console.error("Failed to drain the unused request body.", e2);
    }
  }
}, "drainBody");
var middleware_ensure_req_body_drained_default = drainBody;

// node_modules/wrangler/templates/middleware/middleware-miniflare3-json-error.ts
function reduceError(e2) {
  return {
    name: e2?.name,
    message: e2?.message ?? String(e2),
    stack: e2?.stack,
    cause: e2?.cause === void 0 ? void 0 : reduceError(e2.cause)
  };
}
__name(reduceError, "reduceError");
var jsonError = /* @__PURE__ */ __name(async (request, env, _ctx, middlewareCtx) => {
  try {
    return await middlewareCtx.next(request, env);
  } catch (e2) {
    const error = reduceError(e2);
    return Response.json(error, {
      status: 500,
      headers: { "MF-Experimental-Error-Stack": "true" }
    });
  }
}, "jsonError");
var middleware_miniflare3_json_error_default = jsonError;

// .wrangler/tmp/bundle-KqtDRJ/middleware-insertion-facade.js
var __INTERNAL_WRANGLER_MIDDLEWARE__ = [
  middleware_ensure_req_body_drained_default,
  middleware_miniflare3_json_error_default
];
var middleware_insertion_facade_default = src_default;

// node_modules/wrangler/templates/middleware/common.ts
var __facade_middleware__ = [];
function __facade_register__(...args) {
  __facade_middleware__.push(...args.flat());
}
__name(__facade_register__, "__facade_register__");
function __facade_invokeChain__(request, env, ctx, dispatch, middlewareChain) {
  const [head, ...tail] = middlewareChain;
  const middlewareCtx = {
    dispatch,
    next(newRequest, newEnv) {
      return __facade_invokeChain__(newRequest, newEnv, ctx, dispatch, tail);
    }
  };
  return head(request, env, ctx, middlewareCtx);
}
__name(__facade_invokeChain__, "__facade_invokeChain__");
function __facade_invoke__(request, env, ctx, dispatch, finalMiddleware) {
  return __facade_invokeChain__(request, env, ctx, dispatch, [
    ...__facade_middleware__,
    finalMiddleware
  ]);
}
__name(__facade_invoke__, "__facade_invoke__");

// .wrangler/tmp/bundle-KqtDRJ/middleware-loader.entry.ts
var __Facade_ScheduledController__ = class {
  constructor(scheduledTime, cron, noRetry) {
    this.scheduledTime = scheduledTime;
    this.cron = cron;
    this.#noRetry = noRetry;
  }
  #noRetry;
  noRetry() {
    if (!(this instanceof __Facade_ScheduledController__)) {
      throw new TypeError("Illegal invocation");
    }
    this.#noRetry();
  }
};
__name(__Facade_ScheduledController__, "__Facade_ScheduledController__");
function wrapExportedHandler(worker) {
  if (__INTERNAL_WRANGLER_MIDDLEWARE__ === void 0 || __INTERNAL_WRANGLER_MIDDLEWARE__.length === 0) {
    return worker;
  }
  for (const middleware of __INTERNAL_WRANGLER_MIDDLEWARE__) {
    __facade_register__(middleware);
  }
  const fetchDispatcher = /* @__PURE__ */ __name(function(request, env, ctx) {
    if (worker.fetch === void 0) {
      throw new Error("Handler does not export a fetch() function.");
    }
    return worker.fetch(request, env, ctx);
  }, "fetchDispatcher");
  return {
    ...worker,
    fetch(request, env, ctx) {
      const dispatcher = /* @__PURE__ */ __name(function(type, init) {
        if (type === "scheduled" && worker.scheduled !== void 0) {
          const controller = new __Facade_ScheduledController__(
            Date.now(),
            init.cron ?? "",
            () => {
            }
          );
          return worker.scheduled(controller, env, ctx);
        }
      }, "dispatcher");
      return __facade_invoke__(request, env, ctx, dispatcher, fetchDispatcher);
    }
  };
}
__name(wrapExportedHandler, "wrapExportedHandler");
function wrapWorkerEntrypoint(klass) {
  if (__INTERNAL_WRANGLER_MIDDLEWARE__ === void 0 || __INTERNAL_WRANGLER_MIDDLEWARE__.length === 0) {
    return klass;
  }
  for (const middleware of __INTERNAL_WRANGLER_MIDDLEWARE__) {
    __facade_register__(middleware);
  }
  return class extends klass {
    #fetchDispatcher = (request, env, ctx) => {
      this.env = env;
      this.ctx = ctx;
      if (super.fetch === void 0) {
        throw new Error("Entrypoint class does not define a fetch() function.");
      }
      return super.fetch(request);
    };
    #dispatcher = (type, init) => {
      if (type === "scheduled" && super.scheduled !== void 0) {
        const controller = new __Facade_ScheduledController__(
          Date.now(),
          init.cron ?? "",
          () => {
          }
        );
        return super.scheduled(controller);
      }
    };
    fetch(request) {
      return __facade_invoke__(
        request,
        this.env,
        this.ctx,
        this.#dispatcher,
        this.#fetchDispatcher
      );
    }
  };
}
__name(wrapWorkerEntrypoint, "wrapWorkerEntrypoint");
var WRAPPED_ENTRY;
if (typeof middleware_insertion_facade_default === "object") {
  WRAPPED_ENTRY = wrapExportedHandler(middleware_insertion_facade_default);
} else if (typeof middleware_insertion_facade_default === "function") {
  WRAPPED_ENTRY = wrapWorkerEntrypoint(middleware_insertion_facade_default);
}
var middleware_loader_entry_default = WRAPPED_ENTRY;
export {
  __INTERNAL_WRANGLER_MIDDLEWARE__,
  middleware_loader_entry_default as default
};
//# sourceMappingURL=index.js.map

================
File: .wrangler/tmp/dev-vSRgYD/index.js.map
================
{
  "version": 3,
  "sources": ["../bundle-KqtDRJ/checked-fetch.js", "../../../node_modules/src/src/Router.ts", "../../../node_modules/src/src/StatusError.ts", "../../../node_modules/src/src/createResponse.ts", "../../../node_modules/src/src/json.ts", "../../../node_modules/src/src/error.ts", "../../../node_modules/src/src/status.ts", "../../../node_modules/src/src/text.ts", "../../../node_modules/src/src/html.ts", "../../../node_modules/src/src/jpeg.ts", "../../../node_modules/src/src/png.ts", "../../../node_modules/src/src/webp.ts", "../../../node_modules/src/src/withContent.ts", "../../../node_modules/src/src/withCookies.ts", "../../../node_modules/src/src/withParams.ts", "../../../node_modules/src/src/createCors.ts", "../../../src/config/cloudflare.js", "../../../src/controllers/eventController.js", "../../../src/index.js", "../../../node_modules/wrangler/templates/middleware/middleware-ensure-req-body-drained.ts", "../../../node_modules/wrangler/templates/middleware/middleware-miniflare3-json-error.ts", "../bundle-KqtDRJ/middleware-insertion-facade.js", "../../../node_modules/wrangler/templates/middleware/common.ts", "../bundle-KqtDRJ/middleware-loader.entry.ts"],
  "sourceRoot": "/Users/lancelin/03CS/program/game-mixer/backend/.wrangler/tmp/dev-vSRgYD",
  "sourcesContent": ["const urls = new Set();\n\nfunction checkURL(request, init) {\n\tconst url =\n\t\trequest instanceof URL\n\t\t\t? request\n\t\t\t: new URL(\n\t\t\t\t\t(typeof request === \"string\"\n\t\t\t\t\t\t? new Request(request, init)\n\t\t\t\t\t\t: request\n\t\t\t\t\t).url\n\t\t\t\t);\n\tif (url.port && url.port !== \"443\" && url.protocol === \"https:\") {\n\t\tif (!urls.has(url.toString())) {\n\t\t\turls.add(url.toString());\n\t\t\tconsole.warn(\n\t\t\t\t`WARNING: known issue with \\`fetch()\\` requests to custom HTTPS ports in published Workers:\\n` +\n\t\t\t\t\t` - ${url.toString()} - the custom port will be ignored when the Worker is published using the \\`wrangler deploy\\` command.\\n`\n\t\t\t);\n\t\t}\n\t}\n}\n\nglobalThis.fetch = new Proxy(globalThis.fetch, {\n\tapply(target, thisArg, argArray) {\n\t\tconst [request, init] = argArray;\n\t\tcheckURL(request, init);\n\t\treturn Reflect.apply(target, thisArg, argArray);\n\t},\n});\n", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, "async function uploadToCloudflareImages(buffer, metadata = {}, accountId, apiToken) {\n    const formData = new FormData();\n    formData.append('file', new Blob([buffer]));\n    if (metadata) {\n      formData.append('metadata', JSON.stringify(metadata));\n    }\n  \n    const response = await fetch(\n      `https://api.cloudflare.com/client/v4/accounts/${accountId}/images/v1`,\n      {\n        method: 'POST',\n        headers: {\n          'Authorization': `Bearer ${apiToken}`\n        },\n        body: formData\n      }\n    );\n  \n    const result = await response.json();\n    if (!result.success) {\n      throw new Error(result.errors[0].message);\n    }\n  \n    return {\n      id: result.result.id,\n      url: result.result.variants[0]\n    };\n}\n  \nasync function uploadToCloudflareStream(buffer, metadata = {}, accountId, apiToken) {\n    const response = await fetch(\n      `https://api.cloudflare.com/client/v4/accounts/${accountId}/stream`,\n      {\n        method: 'POST',\n        headers: {\n          'Authorization': `Bearer ${apiToken}`\n        },\n        body: buffer\n      }\n    );\n  \n    const result = await response.json();\n    if (!result.success) {\n      throw new Error(result.errors[0].message);\n    }\n  \n    return {\n      id: result.result.uid,\n      url: `https://watch.cloudflarestream.com/${result.result.uid}`\n    };\n}\n  \nasync function deleteCloudflareImage(imageId, accountId, apiToken) {\n    const response = await fetch(\n      `https://api.cloudflare.com/client/v4/accounts/${accountId}/images/v1/${imageId}`,\n      {\n        method: 'DELETE',\n        headers: {\n          'Authorization': `Bearer ${apiToken}`\n        }\n      }\n    );\n  \n    const result = await response.json();\n    if (!result.success) {\n      throw new Error(result.errors[0].message);\n    }\n}\n  \nasync function deleteCloudflareVideo(videoId, accountId, apiToken) {\n    const response = await fetch(\n      `https://api.cloudflare.com/client/v4/accounts/${accountId}/stream/${videoId}`,\n      {\n        method: 'DELETE',\n        headers: {\n          'Authorization': `Bearer ${apiToken}`\n        }\n      }\n    );\n  \n    const result = await response.json();\n    if (!result.success) {\n      throw new Error(result.errors[0].message);\n    }\n}\n  \nexport {\n    uploadToCloudflareImages,\n    uploadToCloudflareStream,\n    deleteCloudflareImage,\n    deleteCloudflareVideo\n};", "import {\n    uploadToCloudflareImages,\n    uploadToCloudflareStream,\n    deleteCloudflareImage,\n    deleteCloudflareVideo\n  } from '../config/cloudflare';\n  \n  class EventController {\n    async createEvent(req, env) {\n      try {\n        console.log('Starting createEvent');\n        console.log('Account ID:', env.CLOUDFLARE_ACCOUNT_ID);\n        console.log('API Token length:', env.CLOUDFLARE_API_TOKEN?.length);\n        console.log('API Token first 10 chars:', env.CLOUDFLARE_API_TOKEN?.substring(0, 10));\n        console.log('CLOUDFLARE_ACCOUNT_ID:', env.CLOUDFLARE_ACCOUNT_ID);\n        console.log('API Token exists:', !!env.CLOUDFLARE_API_TOKEN);\n  \n        const formData = await req.formData();\n        const eventData = JSON.parse(formData.get('data'));\n        const eventId = crypto.randomUUID();\n        \n        // Handle video upload\n        let videoId = null;\n        let videoUrl = null;\n        const videoFile = formData.get('video');\n        console.log('Video file exists:', !!videoFile);\n        console.log('Video file size:', videoFile?.size);\n        \n        if (videoFile && videoFile.size > 0) {\n          const videoBuffer = await videoFile.arrayBuffer();\n          const videoResult = await uploadToCloudflareStream(\n            videoBuffer,\n            { eventId },\n            env.CLOUDFLARE_ACCOUNT_ID,\n            env.CLOUDFLARE_API_TOKEN\n          );\n          videoId = videoResult.id;\n          videoUrl = videoResult.url;\n        }\n  \n        // Handle image uploads\n        const images = [];\n        for (const [key, value] of formData.entries()) {\n          if (key === 'images' && value.size > 0) {\n            const imageBuffer = await value.arrayBuffer();\n            const imageResult = await uploadToCloudflareImages(\n              imageBuffer,\n              { eventId },\n              env.CLOUDFLARE_ACCOUNT_ID,\n              env.CLOUDFLARE_API_TOKEN\n            );\n            images.push({\n              id: crypto.randomUUID(),\n              image_id: imageResult.id,\n              url: imageResult.url\n            });\n          }\n        }\n  \n        // Database transaction\n        await env.DB.batch([\n          env.DB.prepare(`\n            INSERT INTO events (\n              id, title, time_start, time_end, \n              description_content, description_format,\n              video_id, video_url,\n              created_at, updated_at\n            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)\n          `).bind(\n            eventId,\n            eventData.title,\n            eventData.time.start,\n            eventData.time.end,\n            eventData.description.content,\n            eventData.description.format,\n            videoId,\n            videoUrl\n          ),\n  \n          // Insert image data\n          ...images.map(img => \n            env.DB.prepare(`\n              INSERT INTO event_images (id, event_id, image_id, url) \n              VALUES (?, ?, ?, ?)\n            `).bind(img.id, eventId, img.image_id, img.url)\n          ),\n  \n          // Insert link data\n          ...(eventData.links || []).map(link =>\n            env.DB.prepare(`\n              INSERT INTO event_links (id, event_id, type, description, url)\n              VALUES (?, ?, ?, ?, ?)\n            `).bind(crypto.randomUUID(), eventId, link.type, link.description, link.url)\n          ),\n  \n          // Insert tag data\n          ...(eventData.tags || []).map(tag =>\n            env.DB.prepare(`\n              INSERT INTO event_tags (event_id, tag)\n              VALUES (?, ?)\n            `).bind(eventId, tag)\n          )\n        ]);\n  \n        const event = await this.getEventById(env.DB, eventId);\n        return Response.json({\n          success: true,\n          data: event\n        }, { status: 201 });\n  \n      } catch (error) {\n        console.error('Error in createEvent:', error);\n        try {\n          // Cleanup uploaded files if error occurs\n          if (typeof videoId !== 'undefined' && videoId) {\n            await deleteCloudflareVideo(videoId, env.CLOUDFLARE_ACCOUNT_ID, env.CLOUDFLARE_API_TOKEN);\n          }\n          if (typeof images !== 'undefined' && images?.length > 0) {\n            await Promise.all(images.map(img => \n              deleteCloudflareImage(img.image_id, env.CLOUDFLARE_ACCOUNT_ID, env.CLOUDFLARE_API_TOKEN)\n            ));\n          }\n        } catch (cleanupError) {\n          console.error('Error during cleanup:', cleanupError);\n        }\n  \n        return Response.json({\n          success: false,\n          error: error.message\n        }, { status: 400 });\n      }\n    }\n  \n    async getEvents(req, env) {\n      try {\n        const url = new URL(req.url);\n        const tags = url.searchParams.get('tags');\n        \n        let query = `\n          SELECT \n            e.*,\n            json_group_array(DISTINCT json_object(\n              'id', ei.id,\n              'url', ei.url\n            )) as images,\n            json_group_array(DISTINCT et.tag) as tags,\n            json_group_array(DISTINCT json_object(\n              'type', el.type,\n              'description', el.description,\n              'url', el.url\n            )) as links\n          FROM events e\n          LEFT JOIN event_images ei ON e.id = ei.event_id\n          LEFT JOIN event_tags et ON e.id = et.event_id\n          LEFT JOIN event_links el ON e.id = el.event_id\n        `;\n  \n        const params = [];\n        if (tags) {\n          query += `\n            WHERE e.id IN (\n              SELECT event_id \n              FROM event_tags \n              WHERE tag IN (${tags.split(',').map(() => '?').join(',')})\n              GROUP BY event_id\n              HAVING COUNT(DISTINCT tag) = ?\n            )\n          `;\n          params.push(...tags.split(','), tags.split(',').length);\n        }\n  \n        query += ' GROUP BY e.id ORDER BY e.created_at DESC';\n  \n        const events = await env.DB.prepare(query)\n          .bind(...params)\n          .all();\n  \n        return Response.json({\n          success: true,\n          data: events.results.map(event => ({\n            ...event,\n            images: JSON.parse(event.images),\n            tags: JSON.parse(event.tags),\n            links: JSON.parse(event.links)\n          }))\n        });\n      } catch (error) {\n        console.error('Error in getEvents:', error);\n        return Response.json({\n          success: false,\n          error: error.message\n        }, { status: 400 });\n      }\n    }\n  \n    async getEvent(req, env) {\n      try {\n        const { id } = req.params;\n        const event = await this.getEventById(env.DB, id);\n        \n        if (!event) {\n          return Response.json({\n            success: false,\n            error: 'Event not found'\n          }, { status: 404 });\n        }\n  \n        return Response.json({\n          success: true,\n          data: event\n        });\n      } catch (error) {\n        console.error('Error in getEvent:', error);\n        return Response.json({\n          success: false,\n          error: error.message\n        }, { status: 400 });\n      }\n    }\n  \n    async updateEvent(req, env) {\n      try {\n        const { id } = req.params;\n        const formData = await req.formData();\n        const eventData = JSON.parse(formData.get('data'));\n        \n        const event = await this.getEventById(env.DB, id);\n        if (!event) {\n          return Response.json({\n            success: false,\n            error: 'Event not found'\n          }, { status: 404 });\n        }\n  \n        // Handle video update\n        let videoId = event.video_id;\n        let videoUrl = event.video_url;\n        const videoFile = formData.get('video');\n        if (videoFile && videoFile.size > 0) {\n          if (event.video_id) {\n            await deleteCloudflareVideo(event.video_id, env.CLOUDFLARE_ACCOUNT_ID, env.CLOUDFLARE_API_TOKEN);\n          }\n          const videoBuffer = await videoFile.arrayBuffer();\n          const videoResult = await uploadToCloudflareStream(\n            videoBuffer,\n            { eventId: event.id },\n            env.CLOUDFLARE_ACCOUNT_ID,\n            env.CLOUDFLARE_API_TOKEN\n          );\n          videoId = videoResult.id;\n          videoUrl = videoResult.url;\n        }\n  \n        // Handle image updates\n        let newImages = [];\n        let hasNewImages = false;\n        for (const [key, value] of formData.entries()) {\n          if (key === 'images' && value.size > 0) {\n            hasNewImages = true;\n            const imageBuffer = await value.arrayBuffer();\n            const imageResult = await uploadToCloudflareImages(\n              imageBuffer,\n              { eventId: event.id },\n              env.CLOUDFLARE_ACCOUNT_ID,\n              env.CLOUDFLARE_API_TOKEN\n            );\n            newImages.push({\n              id: crypto.randomUUID(),\n              image_id: imageResult.id,\n              url: imageResult.url\n            });\n          }\n        }\n  \n        // Delete old images if new ones are uploaded\n        if (hasNewImages && event.images) {\n          await Promise.all(\n            event.images.map(img => \n              deleteCloudflareImage(img.image_id, env.CLOUDFLARE_ACCOUNT_ID, env.CLOUDFLARE_API_TOKEN)\n            )\n          );\n        }\n  \n        // Update database\n        await env.DB.batch([\n          env.DB.prepare(`\n            UPDATE events \n            SET title = ?, time_start = ?, time_end = ?, \n                description_content = ?, description_format = ?,\n                video_id = ?, video_url = ?,\n                updated_at = CURRENT_TIMESTAMP\n            WHERE id = ?\n          `).bind(\n            eventData.title,\n            eventData.time.start,\n            eventData.time.end,\n            eventData.description.content,\n            eventData.description.format,\n            videoId,\n            videoUrl,\n            event.id\n          ),\n  \n          // Delete old related data\n          env.DB.prepare('DELETE FROM event_images WHERE event_id = ?').bind(event.id),\n          env.DB.prepare('DELETE FROM event_links WHERE event_id = ?').bind(event.id),\n          env.DB.prepare('DELETE FROM event_tags WHERE event_id = ?').bind(event.id),\n  \n          // Insert new image data\n          ...newImages.map(img => \n            env.DB.prepare(`\n              INSERT INTO event_images (id, event_id, image_id, url)\n              VALUES (?, ?, ?, ?)\n            `).bind(img.id, event.id, img.image_id, img.url)\n          ),\n  \n          // Insert new link data\n          ...(eventData.links || []).map(link =>\n            env.DB.prepare(`\n              INSERT INTO event_links (id, event_id, type, description, url)\n              VALUES (?, ?, ?, ?, ?)\n            `).bind(crypto.randomUUID(), event.id, link.type, link.description, link.url)\n          ),\n  \n          // Insert new tag data\n          ...(eventData.tags || []).map(tag =>\n            env.DB.prepare(`\n              INSERT INTO event_tags (event_id, tag)\n              VALUES (?, ?)\n            `).bind(event.id, tag)\n          )\n        ]);\n  \n        const updatedEvent = await this.getEventById(env.DB, event.id);\n        return Response.json({\n          success: true,\n          data: updatedEvent\n        });\n      } catch (error) {\n        console.error('Error in updateEvent:', error);\n        return Response.json({\n          success: false,\n          error: error.message\n        }, { status: 400 });\n      }\n    }\n  \n    async deleteEvent(req, env) {\n      try {\n        const { id } = req.params;\n        const event = await this.getEventById(env.DB, id);\n        \n        if (!event) {\n          return Response.json({\n            success: false,\n            error: 'Event not found'\n          }, { status: 404 });\n        }\n  \n        // Delete associated media files\n        if (event.video_id) {\n          await deleteCloudflareVideo(event.video_id, env.CLOUDFLARE_ACCOUNT_ID, env.CLOUDFLARE_API_TOKEN);\n        }\n        \n        if (event.images && event.images.length > 0) {\n          await Promise.all(\n            event.images.map(img => \n              deleteCloudflareImage(img.image_id, env.CLOUDFLARE_ACCOUNT_ID, env.CLOUDFLARE_API_TOKEN)\n            )\n          );\n        }\n  \n        // Delete database record (cascade delete will handle related tables)\n        await env.DB.prepare('DELETE FROM events WHERE id = ?')\n          .bind(event.id)\n          .run();\n  \n        return Response.json({\n          success: true,\n          data: {}\n        });\n      } catch (error) {\n        console.error('Error in deleteEvent:', error);\n        return Response.json({\n          success: false,\n          error: error.message\n        }, { status: 400 });\n      }\n    }\n  \n    // Helper function: Get complete event data\n    async getEventById(db, eventId) {\n      const query = `\n        SELECT \n          e.*,\n          json_group_array(DISTINCT json_object(\n            'id', ei.id,\n            'image_id', ei.image_id,\n            'url', ei.url\n          )) as images,\n          json_group_array(DISTINCT et.tag) as tags,\n          json_group_array(DISTINCT json_object(\n            'type', el.type,\n            'description', el.description,\n            'url', el.url\n          )) as links\n        FROM events e\n        LEFT JOIN event_images ei ON e.id = ei.event_id\n        LEFT JOIN event_tags et ON e.id = et.event_id\n        LEFT JOIN event_links el ON e.id = el.event_id\n        WHERE e.id = ?\n        GROUP BY e.id\n      `;\n  \n      const result = await db.prepare(query)\n        .bind(eventId)\n        .first();\n  \n      if (!result) return null;\n  \n      return {\n        ...result,\n        images: JSON.parse(result.images),\n        tags: JSON.parse(result.tags),\n        links: JSON.parse(result.links)\n      };\n    }\n  }\n  \n  export default new EventController();", "import { Router } from 'itty-router';\nimport eventController from './controllers/eventController';\n\n// Create router\nconst router = Router({ base: '/' });\n\n// CORS headers\nconst corsHeaders = {\n  'Access-Control-Allow-Origin': '*',\n  'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',\n  'Access-Control-Allow-Headers': 'Content-Type, Authorization',\n};\n\n// Add CORS to responses\nfunction addCorsHeaders(response) {\n  const newHeaders = new Headers(response.headers);\n  Object.entries(corsHeaders).forEach(([key, value]) => {\n    newHeaders.set(key, value);\n  });\n  return new Response(response.body, {\n    status: response.status,\n    statusText: response.statusText,\n    headers: newHeaders,\n  });\n}\n\n// Routes\nrouter\n  .get('/api/check-auth', async (request, env) => {\n    try {\n      const testResponse = await fetch(\n        `https://api.cloudflare.com/client/v4/accounts/${env.CLOUDFLARE_ACCOUNT_ID}/images/v1/direct_upload`,\n        {\n          method: 'POST',\n          headers: {\n            'Authorization': `Bearer ${env.CLOUDFLARE_API_TOKEN}`\n          }\n        }\n      );\n      const result = await testResponse.json();\n      return Response.json({\n        success: true,\n        account_id: env.CLOUDFLARE_ACCOUNT_ID,\n        token_exists: !!env.CLOUDFLARE_API_TOKEN,\n        can_upload: result.success,\n        details: result\n      });\n    } catch (error) {\n      return Response.json({\n        success: false,\n        error: error.message,\n        account_id: env.CLOUDFLARE_ACCOUNT_ID,\n        token_exists: !!env.CLOUDFLARE_API_TOKEN\n      });\n    }\n  })\n  .post('/api/test-image-upload', async (request, env) => {\n    try {\n      const formData = await request.formData();\n      const imageFile = formData.get('image');\n      if (!imageFile) {\n        throw new Error('No image file provided');\n      }\n      \n      const imageBuffer = await imageFile.arrayBuffer();\n      const uploadFormData = new FormData();\n      uploadFormData.append('file', new Blob([imageBuffer]));\n      \n      const response = await fetch(\n        `https://api.cloudflare.com/client/v4/accounts/${env.CLOUDFLARE_ACCOUNT_ID}/images/v1`,\n        {\n          method: 'POST',\n          headers: {\n            'Authorization': `Bearer ${env.CLOUDFLARE_API_TOKEN}`\n          },\n          body: uploadFormData\n        }\n      );\n      \n      const result = await response.json();\n      return Response.json({\n        success: true,\n        upload_result: result\n      });\n    } catch (error) {\n      return Response.json({\n        success: false,\n        error: error.message\n      }, { status: 400 });\n    }\n  })\n  .get('/api/events', async (request, env) => addCorsHeaders(await eventController.getEvents(request, env)))\n  .get('/api/events/:id', async (request, env) => addCorsHeaders(await eventController.getEvent(request, env)))\n  .post('/api/events', async (request, env) => addCorsHeaders(await eventController.createEvent(request, env)))\n  .put('/api/events/:id', async (request, env) => addCorsHeaders(await eventController.updateEvent(request, env)))\n  .delete('/api/events/:id', async (request, env) => addCorsHeaders(await eventController.deleteEvent(request, env)))\n  .options('*', () => new Response(null, { headers: corsHeaders }))\n  .all('*', () => new Response('Not Found', { status: 404, headers: corsHeaders }));\n\n// Error handler wrapper\nconst handleErrors = fn => async (request, env, ctx) => {\n  try {\n    const response = await fn(request, env, ctx);\n    return response;\n  } catch (err) {\n    console.error(err);\n    return new Response(\n      JSON.stringify({\n        success: false,\n        error: err.message || 'Internal Server Error'\n      }), {\n        status: 500,\n        headers: {\n          'Content-Type': 'application/json',\n          ...corsHeaders\n        }\n      }\n    );\n  }\n};\n\n// Workers entry point\nexport default {\n  fetch: handleErrors(async (request, env, ctx) => {\n    return router.handle(request, env, ctx);\n  })\n};", "import type { Middleware } from \"./common\";\n\nconst drainBody: Middleware = async (request, env, _ctx, middlewareCtx) => {\n\ttry {\n\t\treturn await middlewareCtx.next(request, env);\n\t} finally {\n\t\ttry {\n\t\t\tif (request.body !== null && !request.bodyUsed) {\n\t\t\t\tconst reader = request.body.getReader();\n\t\t\t\twhile (!(await reader.read()).done) {}\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tconsole.error(\"Failed to drain the unused request body.\", e);\n\t\t}\n\t}\n};\n\nexport default drainBody;\n", "import type { Middleware } from \"./common\";\n\ninterface JsonError {\n\tmessage?: string;\n\tname?: string;\n\tstack?: string;\n\tcause?: JsonError;\n}\n\nfunction reduceError(e: any): JsonError {\n\treturn {\n\t\tname: e?.name,\n\t\tmessage: e?.message ?? String(e),\n\t\tstack: e?.stack,\n\t\tcause: e?.cause === undefined ? undefined : reduceError(e.cause),\n\t};\n}\n\n// See comment in `bundle.ts` for details on why this is needed\nconst jsonError: Middleware = async (request, env, _ctx, middlewareCtx) => {\n\ttry {\n\t\treturn await middlewareCtx.next(request, env);\n\t} catch (e: any) {\n\t\tconst error = reduceError(e);\n\t\treturn Response.json(error, {\n\t\t\tstatus: 500,\n\t\t\theaders: { \"MF-Experimental-Error-Stack\": \"true\" },\n\t\t});\n\t}\n};\n\nexport default jsonError;\n", "\t\t\t\timport worker, * as OTHER_EXPORTS from \"/Users/lancelin/03CS/program/game-mixer/backend/src/index.js\";\n\t\t\t\timport * as __MIDDLEWARE_0__ from \"/Users/lancelin/03CS/program/game-mixer/backend/node_modules/wrangler/templates/middleware/middleware-ensure-req-body-drained.ts\";\nimport * as __MIDDLEWARE_1__ from \"/Users/lancelin/03CS/program/game-mixer/backend/node_modules/wrangler/templates/middleware/middleware-miniflare3-json-error.ts\";\n\n\t\t\t\texport * from \"/Users/lancelin/03CS/program/game-mixer/backend/src/index.js\";\n\n\t\t\t\texport const __INTERNAL_WRANGLER_MIDDLEWARE__ = [\n\t\t\t\t\t\n\t\t\t\t\t__MIDDLEWARE_0__.default,__MIDDLEWARE_1__.default\n\t\t\t\t]\n\t\t\t\texport default worker;", "export type Awaitable<T> = T | Promise<T>;\n// TODO: allow dispatching more events?\nexport type Dispatcher = (\n\ttype: \"scheduled\",\n\tinit: { cron?: string }\n) => Awaitable<void>;\n\nexport type IncomingRequest = Request<\n\tunknown,\n\tIncomingRequestCfProperties<unknown>\n>;\n\nexport interface MiddlewareContext {\n\tdispatch: Dispatcher;\n\tnext(request: IncomingRequest, env: any): Awaitable<Response>;\n}\n\nexport type Middleware = (\n\trequest: IncomingRequest,\n\tenv: any,\n\tctx: ExecutionContext,\n\tmiddlewareCtx: MiddlewareContext\n) => Awaitable<Response>;\n\nconst __facade_middleware__: Middleware[] = [];\n\n// The register functions allow for the insertion of one or many middleware,\n// We register internal middleware first in the stack, but have no way of controlling\n// the order that addMiddleware is run in service workers so need an internal function.\nexport function __facade_register__(...args: (Middleware | Middleware[])[]) {\n\t__facade_middleware__.push(...args.flat());\n}\nexport function __facade_registerInternal__(\n\t...args: (Middleware | Middleware[])[]\n) {\n\t__facade_middleware__.unshift(...args.flat());\n}\n\nfunction __facade_invokeChain__(\n\trequest: IncomingRequest,\n\tenv: any,\n\tctx: ExecutionContext,\n\tdispatch: Dispatcher,\n\tmiddlewareChain: Middleware[]\n): Awaitable<Response> {\n\tconst [head, ...tail] = middlewareChain;\n\tconst middlewareCtx: MiddlewareContext = {\n\t\tdispatch,\n\t\tnext(newRequest, newEnv) {\n\t\t\treturn __facade_invokeChain__(newRequest, newEnv, ctx, dispatch, tail);\n\t\t},\n\t};\n\treturn head(request, env, ctx, middlewareCtx);\n}\n\nexport function __facade_invoke__(\n\trequest: IncomingRequest,\n\tenv: any,\n\tctx: ExecutionContext,\n\tdispatch: Dispatcher,\n\tfinalMiddleware: Middleware\n): Awaitable<Response> {\n\treturn __facade_invokeChain__(request, env, ctx, dispatch, [\n\t\t...__facade_middleware__,\n\t\tfinalMiddleware,\n\t]);\n}\n", "// This loads all middlewares exposed on the middleware object and then starts\n// the invocation chain. The big idea is that we can add these to the middleware\n// export dynamically through wrangler, or we can potentially let users directly\n// add them as a sort of \"plugin\" system.\n\nimport ENTRY, { __INTERNAL_WRANGLER_MIDDLEWARE__ } from \"/Users/lancelin/03CS/program/game-mixer/backend/.wrangler/tmp/bundle-KqtDRJ/middleware-insertion-facade.js\";\nimport { __facade_invoke__, __facade_register__, Dispatcher } from \"/Users/lancelin/03CS/program/game-mixer/backend/node_modules/wrangler/templates/middleware/common.ts\";\nimport type { WorkerEntrypointConstructor } from \"/Users/lancelin/03CS/program/game-mixer/backend/.wrangler/tmp/bundle-KqtDRJ/middleware-insertion-facade.js\";\n\n// Preserve all the exports from the worker\nexport * from \"/Users/lancelin/03CS/program/game-mixer/backend/.wrangler/tmp/bundle-KqtDRJ/middleware-insertion-facade.js\";\n\nclass __Facade_ScheduledController__ implements ScheduledController {\n\treadonly #noRetry: ScheduledController[\"noRetry\"];\n\n\tconstructor(\n\t\treadonly scheduledTime: number,\n\t\treadonly cron: string,\n\t\tnoRetry: ScheduledController[\"noRetry\"]\n\t) {\n\t\tthis.#noRetry = noRetry;\n\t}\n\n\tnoRetry() {\n\t\tif (!(this instanceof __Facade_ScheduledController__)) {\n\t\t\tthrow new TypeError(\"Illegal invocation\");\n\t\t}\n\t\t// Need to call native method immediately in case uncaught error thrown\n\t\tthis.#noRetry();\n\t}\n}\n\nfunction wrapExportedHandler(worker: ExportedHandler): ExportedHandler {\n\t// If we don't have any middleware defined, just return the handler as is\n\tif (\n\t\t__INTERNAL_WRANGLER_MIDDLEWARE__ === undefined ||\n\t\t__INTERNAL_WRANGLER_MIDDLEWARE__.length === 0\n\t) {\n\t\treturn worker;\n\t}\n\t// Otherwise, register all middleware once\n\tfor (const middleware of __INTERNAL_WRANGLER_MIDDLEWARE__) {\n\t\t__facade_register__(middleware);\n\t}\n\n\tconst fetchDispatcher: ExportedHandlerFetchHandler = function (\n\t\trequest,\n\t\tenv,\n\t\tctx\n\t) {\n\t\tif (worker.fetch === undefined) {\n\t\t\tthrow new Error(\"Handler does not export a fetch() function.\");\n\t\t}\n\t\treturn worker.fetch(request, env, ctx);\n\t};\n\n\treturn {\n\t\t...worker,\n\t\tfetch(request, env, ctx) {\n\t\t\tconst dispatcher: Dispatcher = function (type, init) {\n\t\t\t\tif (type === \"scheduled\" && worker.scheduled !== undefined) {\n\t\t\t\t\tconst controller = new __Facade_ScheduledController__(\n\t\t\t\t\t\tDate.now(),\n\t\t\t\t\t\tinit.cron ?? \"\",\n\t\t\t\t\t\t() => {}\n\t\t\t\t\t);\n\t\t\t\t\treturn worker.scheduled(controller, env, ctx);\n\t\t\t\t}\n\t\t\t};\n\t\t\treturn __facade_invoke__(request, env, ctx, dispatcher, fetchDispatcher);\n\t\t},\n\t};\n}\n\nfunction wrapWorkerEntrypoint(\n\tklass: WorkerEntrypointConstructor\n): WorkerEntrypointConstructor {\n\t// If we don't have any middleware defined, just return the handler as is\n\tif (\n\t\t__INTERNAL_WRANGLER_MIDDLEWARE__ === undefined ||\n\t\t__INTERNAL_WRANGLER_MIDDLEWARE__.length === 0\n\t) {\n\t\treturn klass;\n\t}\n\t// Otherwise, register all middleware once\n\tfor (const middleware of __INTERNAL_WRANGLER_MIDDLEWARE__) {\n\t\t__facade_register__(middleware);\n\t}\n\n\t// `extend`ing `klass` here so other RPC methods remain callable\n\treturn class extends klass {\n\t\t#fetchDispatcher: ExportedHandlerFetchHandler<Record<string, unknown>> = (\n\t\t\trequest,\n\t\t\tenv,\n\t\t\tctx\n\t\t) => {\n\t\t\tthis.env = env;\n\t\t\tthis.ctx = ctx;\n\t\t\tif (super.fetch === undefined) {\n\t\t\t\tthrow new Error(\"Entrypoint class does not define a fetch() function.\");\n\t\t\t}\n\t\t\treturn super.fetch(request);\n\t\t};\n\n\t\t#dispatcher: Dispatcher = (type, init) => {\n\t\t\tif (type === \"scheduled\" && super.scheduled !== undefined) {\n\t\t\t\tconst controller = new __Facade_ScheduledController__(\n\t\t\t\t\tDate.now(),\n\t\t\t\t\tinit.cron ?? \"\",\n\t\t\t\t\t() => {}\n\t\t\t\t);\n\t\t\t\treturn super.scheduled(controller);\n\t\t\t}\n\t\t};\n\n\t\tfetch(request: Request<unknown, IncomingRequestCfProperties>) {\n\t\t\treturn __facade_invoke__(\n\t\t\t\trequest,\n\t\t\t\tthis.env,\n\t\t\t\tthis.ctx,\n\t\t\t\tthis.#dispatcher,\n\t\t\t\tthis.#fetchDispatcher\n\t\t\t);\n\t\t}\n\t};\n}\n\nlet WRAPPED_ENTRY: ExportedHandler | WorkerEntrypointConstructor | undefined;\nif (typeof ENTRY === \"object\") {\n\tWRAPPED_ENTRY = wrapExportedHandler(ENTRY);\n} else if (typeof ENTRY === \"function\") {\n\tWRAPPED_ENTRY = wrapWorkerEntrypoint(ENTRY);\n}\nexport default WRAPPED_ENTRY;\n"],
  "mappings": "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",
  "names": ["Router", "base", "routes", "other", "__proto__", "Proxy", "get", "target", "prop", "receiver", "path", "fetch", "route", "handlers", "push", "toUpperCase", "RegExp", "replace", "async", "request", "args", "response", "match", "url", "URL", "query", "k", "v", "searchParams", "concat", "method", "regex", "pathname", "params", "groups", "handler", "proxy", "createResponse", "format", "transform", "body", "headers", "rest", "constructor", "name", "Response", "entries", "Object", "fromEntries", "json", "JSON", "stringify", "text", "createResponse", "String", "html", "jpeg", "png", "webp", "videoId", "videoId", "images", "e", "e"]
}

================
File: config/multer.js
================
const multer = require('multer');
const path = require('path');
const fs = require('fs');

// Ensure uploads directory exists
const uploadDir = 'uploads';
if (!fs.existsSync(uploadDir)) {
  fs.mkdirSync(uploadDir);
}

const storage = multer.diskStorage({
  destination: (req, file, cb) => {
    cb(null, 'uploads/');
  },
  filename: (req, file, cb) => {
    const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);
    cb(null, file.fieldname + '-' + uniqueSuffix + path.extname(file.originalname));
  }
});

const fileFilter = (req, file, cb) => {
  if (file.fieldname === 'video') {
    if (file.mimetype.startsWith('video/')) {
      cb(null, true);
    } else {
      cb(new Error('Invalid video format'), false);
    }
  } else if (file.fieldname === 'images') {
    if (file.mimetype.startsWith('image/')) {
      cb(null, true);
    } else {
      cb(new Error('Invalid image format'), false);
    }
  } else {
    cb(new Error('Unexpected field'), false);
  }
};

const upload = multer({
  storage: storage,
  fileFilter: fileFilter,
  limits: {
    fileSize: 50 * 1024 * 1024, // 50MB limit
    files: 10 // Maximum 10 files per request
  }
});

module.exports = upload;

================
File: controllers/eventController.js
================
const Event = require('../models/Event');
const fs = require('fs').promises;
const path = require('path');

// Helper function to delete files
const deleteFile = async (filename) => {
  if (!filename) return;
  const filepath = path.join('uploads', filename);
  try {
    await fs.unlink(filepath);
  } catch (error) {
    console.error('Error deleting file:', error);
  }
};

exports.createEvent = async (req, res) => {
  try {
    const eventData = JSON.parse(req.body.data);
    
    // Handle file uploads
    if (req.files) {
      if (req.files.video) {
        eventData.video = {
          url: `/uploads/${req.files.video[0].filename}`,
          filename: req.files.video[0].filename
        };
      }
      
      if (req.files.images) {
        eventData.images = req.files.images.map(file => ({
          url: `/uploads/${file.filename}`,
          filename: file.filename
        }));
      }
    }

    const event = new Event(eventData);
    await event.save();
    
    res.status(201).json({
      success: true,
      data: event
    });
  } catch (error) {
    // Clean up uploaded files if event creation fails
    if (req.files) {
      if (req.files.video) {
        await deleteFile(req.files.video[0].filename);
      }
      if (req.files.images) {
        await Promise.all(req.files.images.map(file => deleteFile(file.filename)));
      }
    }
    
    res.status(400).json({
      success: false,
      error: error.message
    });
  }
};

exports.getEvents = async (req, res) => {
  try {
    const { tags } = req.query;
    let query = {};
    
    if (tags) {
      query.tags = { $all: tags.split(',') };
    }
    
    const events = await Event.find(query).sort({ createdAt: -1 });
    
    res.json({
      success: true,
      data: events
    });
  } catch (error) {
    res.status(400).json({
      success: false,
      error: error.message
    });
  }
};

exports.getEvent = async (req, res) => {
  try {
    const event = await Event.findById(req.params.id);
    if (!event) {
      return res.status(404).json({
        success: false,
        error: 'Event not found'
      });
    }
    
    res.json({
      success: true,
      data: event
    });
  } catch (error) {
    res.status(400).json({
      success: false,
      error: error.message
    });
  }
};

exports.updateEvent = async (req, res) => {
  try {
    const event = await Event.findById(req.params.id);
    if (!event) {
      return res.status(404).json({
        success: false,
        error: 'Event not found'
      });
    }

    const eventData = JSON.parse(req.body.data);
    
    // Handle file uploads
    if (req.files) {
      if (req.files.video) {
        // Delete old video if it exists
        if (event.video && event.video.filename) {
          await deleteFile(event.video.filename);
        }
        eventData.video = {
          url: `/uploads/${req.files.video[0].filename}`,
          filename: req.files.video[0].filename
        };
      }
      
      if (req.files.images) {
        // Delete old images
        if (event.images && event.images.length > 0) {
          await Promise.all(event.images.map(img => deleteFile(img.filename)));
        }
        eventData.images = req.files.images.map(file => ({
          url: `/uploads/${file.filename}`,
          filename: file.filename
        }));
      }
    }

    const updatedEvent = await Event.findByIdAndUpdate(
      req.params.id,
      { $set: eventData },
      { new: true, runValidators: true }
    );
    
    res.json({
      success: true,
      data: updatedEvent
    });
  } catch (error) {
    // Clean up uploaded files if update fails
    if (req.files) {
      if (req.files.video) {
        await deleteFile(req.files.video[0].filename);
      }
      if (req.files.images) {
        await Promise.all(req.files.images.map(file => deleteFile(file.filename)));
      }
    }
    
    res.status(400).json({
      success: false,
      error: error.message
    });
  }
};

exports.deleteEvent = async (req, res) => {
  try {
    const event = await Event.findById(req.params.id);
    if (!event) {
      return res.status(404).json({
        success: false,
        error: 'Event not found'
      });
    }

    // Delete associated files
    if (event.video && event.video.filename) {
      await deleteFile(event.video.filename);
    }
    
    if (event.images && event.images.length > 0) {
      await Promise.all(event.images.map(img => deleteFile(img.filename)));
    }

    await event.deleteOne();
    
    res.json({
      success: true,
      data: {}
    });
  } catch (error) {
    res.status(400).json({
      success: false,
      error: error.message
    });
  }
};

================
File: models/Event.js
================
const mongoose = require('mongoose');

const linkSchema = new mongoose.Schema({
  type: {
    type: String,
    required: true,
    trim: true
  },
  description: {
    type: String,
    required: true,
    trim: true
  },
  url: {
    type: String,
    required: true,
    trim: true
  }
});

const eventSchema = new mongoose.Schema({
  title: {
    type: String,
    required: true,
    trim: true
  },
  time: {
    start: {
      type: Date,
      required: true
    },
    end: {
      type: Date,
      required: true
    }
  },
  description: {
    content: {
      type: String,
      required: true
    },
    format: {
      type: String,
      enum: ['plain', 'rich'],
      default: 'plain'
    }
  },
  video: {
    url: String,
    filename: String
  },
  images: [{
    url: String,
    filename: String
  }],
  links: [linkSchema],
  tags: [{
    type: String,
    trim: true
  }]
}, {
  timestamps: true
});

eventSchema.index({ title: 'text', 'description.content': 'text', tags: 'text' });

module.exports = mongoose.model('Event', eventSchema);

================
File: routes/events.js
================
const express = require('express');
const router = express.Router();
const eventController = require('../controllers/eventController');
const upload = require('../config/multer');

const uploadFields = upload.fields([
  { name: 'video', maxCount: 1 },
  { name: 'images', maxCount: 10 }
]);

router.post('/', uploadFields, eventController.createEvent);
router.get('/', eventController.getEvents);
router.get('/:id', eventController.getEvent);
router.put('/:id', uploadFields, eventController.updateEvent);
router.delete('/:id', eventController.deleteEvent);

module.exports = router;

================
File: src/config/cloudflare.js
================
async function uploadToCloudflareImages(buffer, metadata = {}, accountId, apiToken) {
    const formData = new FormData();
    formData.append('file', new Blob([buffer]));
    if (metadata) {
      formData.append('metadata', JSON.stringify(metadata));
    }
  
    const response = await fetch(
      `https://api.cloudflare.com/client/v4/accounts/${accountId}/images/v1`,
      {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${apiToken}`
        },
        body: formData
      }
    );
  
    const result = await response.json();
    if (!result.success) {
      throw new Error(result.errors[0].message);
    }
  
    return {
      id: result.result.id,
      url: result.result.variants[0]
    };
}
  
async function uploadToCloudflareStream(buffer, metadata = {}, accountId, apiToken) {
    const response = await fetch(
      `https://api.cloudflare.com/client/v4/accounts/${accountId}/stream`,
      {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${apiToken}`
        },
        body: buffer
      }
    );
  
    const result = await response.json();
    if (!result.success) {
      throw new Error(result.errors[0].message);
    }
  
    return {
      id: result.result.uid,
      url: `https://watch.cloudflarestream.com/${result.result.uid}`
    };
}
  
async function deleteCloudflareImage(imageId, accountId, apiToken) {
    const response = await fetch(
      `https://api.cloudflare.com/client/v4/accounts/${accountId}/images/v1/${imageId}`,
      {
        method: 'DELETE',
        headers: {
          'Authorization': `Bearer ${apiToken}`
        }
      }
    );
  
    const result = await response.json();
    if (!result.success) {
      throw new Error(result.errors[0].message);
    }
}
  
async function deleteCloudflareVideo(videoId, accountId, apiToken) {
    const response = await fetch(
      `https://api.cloudflare.com/client/v4/accounts/${accountId}/stream/${videoId}`,
      {
        method: 'DELETE',
        headers: {
          'Authorization': `Bearer ${apiToken}`
        }
      }
    );
  
    const result = await response.json();
    if (!result.success) {
      throw new Error(result.errors[0].message);
    }
}
  
export {
    uploadToCloudflareImages,
    uploadToCloudflareStream,
    deleteCloudflareImage,
    deleteCloudflareVideo
};

================
File: src/controllers/eventController.js
================
import {
    uploadToCloudflareImages,
    uploadToCloudflareStream,
    deleteCloudflareImage,
    deleteCloudflareVideo
  } from '../config/cloudflare';
  
  class EventController {
    async createEvent(req, env) {
      try {
        console.log('Starting createEvent');
        console.log('Account ID:', env.CLOUDFLARE_ACCOUNT_ID);
        console.log('API Token length:', env.CLOUDFLARE_API_TOKEN?.length);
        console.log('API Token first 10 chars:', env.CLOUDFLARE_API_TOKEN?.substring(0, 10));
        console.log('CLOUDFLARE_ACCOUNT_ID:', env.CLOUDFLARE_ACCOUNT_ID);
        console.log('API Token exists:', !!env.CLOUDFLARE_API_TOKEN);
  
        const formData = await req.formData();
        const eventData = JSON.parse(formData.get('data'));
        const eventId = crypto.randomUUID();
        
        // Handle video upload
        let videoId = null;
        let videoUrl = null;
        const videoFile = formData.get('video');
        console.log('Video file exists:', !!videoFile);
        console.log('Video file size:', videoFile?.size);
        
        if (videoFile && videoFile.size > 0) {
          const videoBuffer = await videoFile.arrayBuffer();
          const videoResult = await uploadToCloudflareStream(
            videoBuffer,
            { eventId },
            env.CLOUDFLARE_ACCOUNT_ID,
            env.CLOUDFLARE_API_TOKEN
          );
          videoId = videoResult.id;
          videoUrl = videoResult.url;
        }
  
        // Handle image uploads
        const images = [];
        for (const [key, value] of formData.entries()) {
          if (key === 'images' && value.size > 0) {
            const imageBuffer = await value.arrayBuffer();
            const imageResult = await uploadToCloudflareImages(
              imageBuffer,
              { eventId },
              env.CLOUDFLARE_ACCOUNT_ID,
              env.CLOUDFLARE_API_TOKEN
            );
            images.push({
              id: crypto.randomUUID(),
              image_id: imageResult.id,
              url: imageResult.url
            });
          }
        }
  
        // Database transaction
        await env.DB.batch([
          env.DB.prepare(`
            INSERT INTO events (
              id, title, time_start, time_end, 
              description_content, description_format,
              video_id, video_url,
              created_at, updated_at
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
          `).bind(
            eventId,
            eventData.title,
            eventData.time.start,
            eventData.time.end,
            eventData.description.content,
            eventData.description.format,
            videoId,
            videoUrl
          ),
  
          // Insert image data
          ...images.map(img => 
            env.DB.prepare(`
              INSERT INTO event_images (id, event_id, image_id, url) 
              VALUES (?, ?, ?, ?)
            `).bind(img.id, eventId, img.image_id, img.url)
          ),
  
          // Insert link data
          ...(eventData.links || []).map(link =>
            env.DB.prepare(`
              INSERT INTO event_links (id, event_id, type, description, url)
              VALUES (?, ?, ?, ?, ?)
            `).bind(crypto.randomUUID(), eventId, link.type, link.description, link.url)
          ),
  
          // Insert tag data
          ...(eventData.tags || []).map(tag =>
            env.DB.prepare(`
              INSERT INTO event_tags (event_id, tag)
              VALUES (?, ?)
            `).bind(eventId, tag)
          )
        ]);
  
        const event = await this.getEventById(env.DB, eventId);
        return Response.json({
          success: true,
          data: event
        }, { status: 201 });
  
      } catch (error) {
        console.error('Error in createEvent:', error);
        try {
          // Cleanup uploaded files if error occurs
          if (typeof videoId !== 'undefined' && videoId) {
            await deleteCloudflareVideo(videoId, env.CLOUDFLARE_ACCOUNT_ID, env.CLOUDFLARE_API_TOKEN);
          }
          if (typeof images !== 'undefined' && images?.length > 0) {
            await Promise.all(images.map(img => 
              deleteCloudflareImage(img.image_id, env.CLOUDFLARE_ACCOUNT_ID, env.CLOUDFLARE_API_TOKEN)
            ));
          }
        } catch (cleanupError) {
          console.error('Error during cleanup:', cleanupError);
        }
  
        return Response.json({
          success: false,
          error: error.message
        }, { status: 400 });
      }
    }
  
    async getEvents(req, env) {
      try {
        const url = new URL(req.url);
        const tags = url.searchParams.get('tags');
        
        let query = `
          SELECT 
            e.*,
            json_group_array(DISTINCT json_object(
              'id', ei.id,
              'url', ei.url
            )) as images,
            json_group_array(DISTINCT et.tag) as tags,
            json_group_array(DISTINCT json_object(
              'type', el.type,
              'description', el.description,
              'url', el.url
            )) as links
          FROM events e
          LEFT JOIN event_images ei ON e.id = ei.event_id
          LEFT JOIN event_tags et ON e.id = et.event_id
          LEFT JOIN event_links el ON e.id = el.event_id
        `;
  
        const params = [];
        if (tags) {
          query += `
            WHERE e.id IN (
              SELECT event_id 
              FROM event_tags 
              WHERE tag IN (${tags.split(',').map(() => '?').join(',')})
              GROUP BY event_id
              HAVING COUNT(DISTINCT tag) = ?
            )
          `;
          params.push(...tags.split(','), tags.split(',').length);
        }
  
        query += ' GROUP BY e.id ORDER BY e.created_at DESC';
  
        const events = await env.DB.prepare(query)
          .bind(...params)
          .all();
  
        return Response.json({
          success: true,
          data: events.results.map(event => ({
            ...event,
            images: JSON.parse(event.images),
            tags: JSON.parse(event.tags),
            links: JSON.parse(event.links)
          }))
        });
      } catch (error) {
        console.error('Error in getEvents:', error);
        return Response.json({
          success: false,
          error: error.message
        }, { status: 400 });
      }
    }
  
    async getEvent(req, env) {
      try {
        const { id } = req.params;
        const event = await this.getEventById(env.DB, id);
        
        if (!event) {
          return Response.json({
            success: false,
            error: 'Event not found'
          }, { status: 404 });
        }
  
        return Response.json({
          success: true,
          data: event
        });
      } catch (error) {
        console.error('Error in getEvent:', error);
        return Response.json({
          success: false,
          error: error.message
        }, { status: 400 });
      }
    }
  
    async updateEvent(req, env) {
      try {
        const { id } = req.params;
        const formData = await req.formData();
        const eventData = JSON.parse(formData.get('data'));
        
        const event = await this.getEventById(env.DB, id);
        if (!event) {
          return Response.json({
            success: false,
            error: 'Event not found'
          }, { status: 404 });
        }
  
        // Handle video update
        let videoId = event.video_id;
        let videoUrl = event.video_url;
        const videoFile = formData.get('video');
        if (videoFile && videoFile.size > 0) {
          if (event.video_id) {
            await deleteCloudflareVideo(event.video_id, env.CLOUDFLARE_ACCOUNT_ID, env.CLOUDFLARE_API_TOKEN);
          }
          const videoBuffer = await videoFile.arrayBuffer();
          const videoResult = await uploadToCloudflareStream(
            videoBuffer,
            { eventId: event.id },
            env.CLOUDFLARE_ACCOUNT_ID,
            env.CLOUDFLARE_API_TOKEN
          );
          videoId = videoResult.id;
          videoUrl = videoResult.url;
        }
  
        // Handle image updates
        let newImages = [];
        let hasNewImages = false;
        for (const [key, value] of formData.entries()) {
          if (key === 'images' && value.size > 0) {
            hasNewImages = true;
            const imageBuffer = await value.arrayBuffer();
            const imageResult = await uploadToCloudflareImages(
              imageBuffer,
              { eventId: event.id },
              env.CLOUDFLARE_ACCOUNT_ID,
              env.CLOUDFLARE_API_TOKEN
            );
            newImages.push({
              id: crypto.randomUUID(),
              image_id: imageResult.id,
              url: imageResult.url
            });
          }
        }
  
        // Delete old images if new ones are uploaded
        if (hasNewImages && event.images) {
          await Promise.all(
            event.images.map(img => 
              deleteCloudflareImage(img.image_id, env.CLOUDFLARE_ACCOUNT_ID, env.CLOUDFLARE_API_TOKEN)
            )
          );
        }
  
        // Update database
        await env.DB.batch([
          env.DB.prepare(`
            UPDATE events 
            SET title = ?, time_start = ?, time_end = ?, 
                description_content = ?, description_format = ?,
                video_id = ?, video_url = ?,
                updated_at = CURRENT_TIMESTAMP
            WHERE id = ?
          `).bind(
            eventData.title,
            eventData.time.start,
            eventData.time.end,
            eventData.description.content,
            eventData.description.format,
            videoId,
            videoUrl,
            event.id
          ),
  
          // Delete old related data
          env.DB.prepare('DELETE FROM event_images WHERE event_id = ?').bind(event.id),
          env.DB.prepare('DELETE FROM event_links WHERE event_id = ?').bind(event.id),
          env.DB.prepare('DELETE FROM event_tags WHERE event_id = ?').bind(event.id),
  
          // Insert new image data
          ...newImages.map(img => 
            env.DB.prepare(`
              INSERT INTO event_images (id, event_id, image_id, url)
              VALUES (?, ?, ?, ?)
            `).bind(img.id, event.id, img.image_id, img.url)
          ),
  
          // Insert new link data
          ...(eventData.links || []).map(link =>
            env.DB.prepare(`
              INSERT INTO event_links (id, event_id, type, description, url)
              VALUES (?, ?, ?, ?, ?)
            `).bind(crypto.randomUUID(), event.id, link.type, link.description, link.url)
          ),
  
          // Insert new tag data
          ...(eventData.tags || []).map(tag =>
            env.DB.prepare(`
              INSERT INTO event_tags (event_id, tag)
              VALUES (?, ?)
            `).bind(event.id, tag)
          )
        ]);
  
        const updatedEvent = await this.getEventById(env.DB, event.id);
        return Response.json({
          success: true,
          data: updatedEvent
        });
      } catch (error) {
        console.error('Error in updateEvent:', error);
        return Response.json({
          success: false,
          error: error.message
        }, { status: 400 });
      }
    }
  
    async deleteEvent(req, env) {
      try {
        const { id } = req.params;
        const event = await this.getEventById(env.DB, id);
        
        if (!event) {
          return Response.json({
            success: false,
            error: 'Event not found'
          }, { status: 404 });
        }
  
        // Delete associated media files
        if (event.video_id) {
          await deleteCloudflareVideo(event.video_id, env.CLOUDFLARE_ACCOUNT_ID, env.CLOUDFLARE_API_TOKEN);
        }
        
        if (event.images && event.images.length > 0) {
          await Promise.all(
            event.images.map(img => 
              deleteCloudflareImage(img.image_id, env.CLOUDFLARE_ACCOUNT_ID, env.CLOUDFLARE_API_TOKEN)
            )
          );
        }
  
        // Delete database record (cascade delete will handle related tables)
        await env.DB.prepare('DELETE FROM events WHERE id = ?')
          .bind(event.id)
          .run();
  
        return Response.json({
          success: true,
          data: {}
        });
      } catch (error) {
        console.error('Error in deleteEvent:', error);
        return Response.json({
          success: false,
          error: error.message
        }, { status: 400 });
      }
    }
  
    // Helper function: Get complete event data
    async getEventById(db, eventId) {
      const query = `
        SELECT 
          e.*,
          json_group_array(DISTINCT json_object(
            'id', ei.id,
            'image_id', ei.image_id,
            'url', ei.url
          )) as images,
          json_group_array(DISTINCT et.tag) as tags,
          json_group_array(DISTINCT json_object(
            'type', el.type,
            'description', el.description,
            'url', el.url
          )) as links
        FROM events e
        LEFT JOIN event_images ei ON e.id = ei.event_id
        LEFT JOIN event_tags et ON e.id = et.event_id
        LEFT JOIN event_links el ON e.id = el.event_id
        WHERE e.id = ?
        GROUP BY e.id
      `;
  
      const result = await db.prepare(query)
        .bind(eventId)
        .first();
  
      if (!result) return null;
  
      return {
        ...result,
        images: JSON.parse(result.images),
        tags: JSON.parse(result.tags),
        links: JSON.parse(result.links)
      };
    }
  }
  
  export default new EventController();

================
File: src/index.js
================
import { Router } from 'itty-router';
import eventController from './controllers/eventController';

// Create router
const router = Router({ base: '/' });

// CORS headers
const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
  'Access-Control-Allow-Headers': 'Content-Type, Authorization',
};

// Add CORS to responses
function addCorsHeaders(response) {
  const newHeaders = new Headers(response.headers);
  Object.entries(corsHeaders).forEach(([key, value]) => {
    newHeaders.set(key, value);
  });
  return new Response(response.body, {
    status: response.status,
    statusText: response.statusText,
    headers: newHeaders,
  });
}

// Routes
router
  .get('/api/check-auth', async (request, env) => {
    try {
      const testResponse = await fetch(
        `https://api.cloudflare.com/client/v4/accounts/${env.CLOUDFLARE_ACCOUNT_ID}/images/v1/direct_upload`,
        {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${env.CLOUDFLARE_API_TOKEN}`
          }
        }
      );
      const result = await testResponse.json();
      return Response.json({
        success: true,
        account_id: env.CLOUDFLARE_ACCOUNT_ID,
        token_exists: !!env.CLOUDFLARE_API_TOKEN,
        can_upload: result.success,
        details: result
      });
    } catch (error) {
      return Response.json({
        success: false,
        error: error.message,
        account_id: env.CLOUDFLARE_ACCOUNT_ID,
        token_exists: !!env.CLOUDFLARE_API_TOKEN
      });
    }
  })
  .post('/api/test-image-upload', async (request, env) => {
    try {
      const formData = await request.formData();
      const imageFile = formData.get('image');
      if (!imageFile) {
        throw new Error('No image file provided');
      }
      
      const imageBuffer = await imageFile.arrayBuffer();
      const uploadFormData = new FormData();
      uploadFormData.append('file', new Blob([imageBuffer]));
      
      const response = await fetch(
        `https://api.cloudflare.com/client/v4/accounts/${env.CLOUDFLARE_ACCOUNT_ID}/images/v1`,
        {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${env.CLOUDFLARE_API_TOKEN}`
          },
          body: uploadFormData
        }
      );
      
      const result = await response.json();
      return Response.json({
        success: true,
        upload_result: result
      });
    } catch (error) {
      return Response.json({
        success: false,
        error: error.message
      }, { status: 400 });
    }
  })
  .get('/api/events', async (request, env) => addCorsHeaders(await eventController.getEvents(request, env)))
  .get('/api/events/:id', async (request, env) => addCorsHeaders(await eventController.getEvent(request, env)))
  .post('/api/events', async (request, env) => addCorsHeaders(await eventController.createEvent(request, env)))
  .put('/api/events/:id', async (request, env) => addCorsHeaders(await eventController.updateEvent(request, env)))
  .delete('/api/events/:id', async (request, env) => addCorsHeaders(await eventController.deleteEvent(request, env)))
  .options('*', () => new Response(null, { headers: corsHeaders }))
  .all('*', () => new Response('Not Found', { status: 404, headers: corsHeaders }));

// Error handler wrapper
const handleErrors = fn => async (request, env, ctx) => {
  try {
    const response = await fn(request, env, ctx);
    return response;
  } catch (err) {
    console.error(err);
    return new Response(
      JSON.stringify({
        success: false,
        error: err.message || 'Internal Server Error'
      }), {
        status: 500,
        headers: {
          'Content-Type': 'application/json',
          ...corsHeaders
        }
      }
    );
  }
};

// Workers entry point
export default {
  fetch: handleErrors(async (request, env, ctx) => {
    return router.handle(request, env, ctx);
  })
};

================
File: src/schema.sql
================
-- D1 数据库模式
CREATE TABLE IF NOT EXISTS events (
  id TEXT PRIMARY KEY,
  title TEXT NOT NULL,
  time_start TEXT NOT NULL,
  time_end TEXT NOT NULL,
  description_content TEXT NOT NULL,
  description_format TEXT CHECK(description_format IN ('plain', 'rich')) DEFAULT 'plain',
  created_at TEXT DEFAULT CURRENT_TIMESTAMP,
  updated_at TEXT DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE IF NOT EXISTS event_images (
  id TEXT PRIMARY KEY,
  event_id TEXT NOT NULL,
  image_id TEXT NOT NULL,
  url TEXT NOT NULL,
  FOREIGN KEY(event_id) REFERENCES events(id) ON DELETE CASCADE
);

CREATE TABLE IF NOT EXISTS event_links (
  id TEXT PRIMARY KEY,
  event_id TEXT NOT NULL,
  type TEXT NOT NULL,
  description TEXT NOT NULL,
  url TEXT NOT NULL,
  FOREIGN KEY(event_id) REFERENCES events(id) ON DELETE CASCADE
);

CREATE TABLE IF NOT EXISTS event_tags (
  event_id TEXT NOT NULL,
  tag TEXT NOT NULL,
  PRIMARY KEY(event_id, tag),
  FOREIGN KEY(event_id) REFERENCES events(id) ON DELETE CASCADE
);

================
File: tests/helpers/fileHelper.js
================
const path = require('path');
const fs = require('fs');

// 创建测试用的临时文件
const createTestFiles = () => {
  const testDir = path.join(__dirname, '../temp');
  if (!fs.existsSync(testDir)) {
    fs.mkdirSync(testDir, { recursive: true });
  }

  // 创建测试图片
  const imageFile = path.join(testDir, 'test-image.jpg');
  fs.writeFileSync(imageFile, 'fake image content');

  // 创建测试视频
  const videoFile = path.join(testDir, 'test-video.mp4');
  fs.writeFileSync(videoFile, 'fake video content');

  return {
    imageFile,
    videoFile
  };
};

// 清理测试文件
const cleanupTestFiles = () => {
  const testDir = path.join(__dirname, '../temp');
  if (fs.existsSync(testDir)) {
    fs.rmSync(testDir, { recursive: true });
  }
};

module.exports = {
  createTestFiles,
  cleanupTestFiles
};

================
File: tests/events.test.js
================
const request = require('supertest');
const { app } = require('../server');
const Event = require('../models/Event');
const { createTestFiles, cleanupTestFiles } = require('./helpers/fileHelper');

describe('Event API Tests', () => {
  let testFiles;
  let createdEventId;

  beforeAll(() => {
    testFiles = createTestFiles();
  });

  afterAll(() => {
    cleanupTestFiles();
  });

  beforeEach(async () => {
    await Event.deleteMany({});
  });

  // 测试创建事件
  describe('POST /api/events', () => {
    it('should create a new event with files', async () => {
      const eventData = {
        title: '测试活动',
        time: {
          start: new Date('2025-03-01T10:00:00Z'),
          end: new Date('2025-03-01T12:00:00Z')
        },
        description: {
          content: '这是一个测试活动的描述',
          format: 'plain'
        },
        links: [{
          type: '注册',
          description: '活动注册链接',
          url: 'https://example.com/register'
        }],
        tags: ['测试', '活动']
      };

      const response = await request(app)
        .post('/api/events')
        .field('data', JSON.stringify(eventData))
        .attach('video', testFiles.videoFile)
        .attach('images', testFiles.imageFile)
        .expect(201);

      expect(response.body.success).toBe(true);
      expect(response.body.data.title).toBe(eventData.title);
      expect(response.body.data.video).toBeDefined();
      expect(response.body.data.images).toHaveLength(1);

      createdEventId = response.body.data._id;
    });

    it('should validate required fields', async () => {
      const response = await request(app)
        .post('/api/events')
        .field('data', JSON.stringify({ title: '测试活动' }))
        .expect(400);

      expect(response.body.success).toBe(false);
      expect(response.body.error).toBeDefined();
    });
  });

  // 测试获取事件列表
  describe('GET /api/events', () => {
    beforeEach(async () => {
      // 创建测试数据
      await Event.create([
        {
          title: '活动 1',
          time: {
            start: new Date('2025-03-01T10:00:00Z'),
            end: new Date('2025-03-01T12:00:00Z')
          },
          description: { content: '描述 1', format: 'plain' },
          tags: ['标签1', '标签2']
        },
        {
          title: '活动 2',
          time: {
            start: new Date('2025-03-02T10:00:00Z'),
            end: new Date('2025-03-02T12:00:00Z')
          },
          description: { content: '描述 2', format: 'plain' },
          tags: ['标签2', '标签3']
        }
      ]);
    });

    it('should get all events when no filter', async () => {
      const response = await request(app)
        .get('/api/events')
        .expect(200);

      expect(response.body.success).toBe(true);
      expect(response.body.data).toHaveLength(2);
    });

    it('should filter events by tags', async () => {
      const response = await request(app)
        .get('/api/events')
        .query({ tags: '标签1' })
        .expect(200);

      expect(response.body.success).toBe(true);
      expect(response.body.data).toHaveLength(1);
      expect(response.body.data[0].tags).toContain('标签1');
    });
  });

  // 测试获取单个事件
  describe('GET /api/events/:id', () => {
    let testEventId;

    beforeEach(async () => {
      const event = await Event.create({
        title: '测试活动',
        time: {
          start: new Date('2025-03-01T10:00:00Z'),
          end: new Date('2025-03-01T12:00:00Z')
        },
        description: { content: '描述', format: 'plain' }
      });
      testEventId = event._id;
    });

    it('should get an event by id', async () => {
      const response = await request(app)
        .get(`/api/events/${testEventId}`)
        .expect(200);

      expect(response.body.success).toBe(true);
      expect(response.body.data._id).toBe(testEventId.toString());
    });

    it('should return 404 for non-existent event', async () => {
      const fakeId = '507f1f77bcf86cd799439011';
      const response = await request(app)
        .get(`/api/events/${fakeId}`)
        .expect(404);

      expect(response.body.success).toBe(false);
      expect(response.body.error).toBe('Event not found');
    });
  });

  // 测试更新事件
  describe('PUT /api/events/:id', () => {
    let testEventId;

    beforeEach(async () => {
      const event = await Event.create({
        title: '原始活动',
        time: {
          start: new Date('2025-03-01T10:00:00Z'),
          end: new Date('2025-03-01T12:00:00Z')
        },
        description: { content: '原始描述', format: 'plain' }
      });
      testEventId = event._id;
    });

    it('should update an event with new files', async () => {
      const updateData = {
        title: '更新后的活动',
        time: {
          start: new Date('2025-03-02T10:00:00Z'),
          end: new Date('2025-03-02T12:00:00Z')
        },
        description: { content: '更新后的描述', format: 'plain' }
      };

      const response = await request(app)
        .put(`/api/events/${testEventId}`)
        .field('data', JSON.stringify(updateData))
        .attach('video', testFiles.videoFile)
        .attach('images', testFiles.imageFile)
        .expect(200);

      expect(response.body.success).toBe(true);
      expect(response.body.data.title).toBe(updateData.title);
      expect(response.body.data.video).toBeDefined();
      expect(response.body.data.images).toHaveLength(1);
    });
  });

  // 测试删除事件
  describe('DELETE /api/events/:id', () => {
    let testEventId;

    beforeEach(async () => {
      const event = await Event.create({
        title: '待删除活动',
        time: {
          start: new Date('2025-03-01T10:00:00Z'),
          end: new Date('2025-03-01T12:00:00Z')
        },
        description: { content: '描述', format: 'plain' }
      });
      testEventId = event._id;
    });

    it('should delete an event', async () => {
      const response = await request(app)
        .delete(`/api/events/${testEventId}`)
        .expect(200);

      expect(response.body.success).toBe(true);

      // 验证事件已被删除
      const deletedEvent = await Event.findById(testEventId);
      expect(deletedEvent).toBeNull();
    });
  });
});

================
File: tests/setup.js
================
// tests/setup.js
const mongoose = require('mongoose');
const { MongoMemoryServer } = require('mongodb-memory-server');

let mongoServer;

beforeAll(async () => {
  // 确保没有现有的连接
  await mongoose.disconnect();
  
  mongoServer = await MongoMemoryServer.create();
  const mongoUri = mongoServer.getUri();
  await mongoose.connect(mongoUri);
});

afterAll(async () => {
  await mongoose.disconnect();
  await mongoServer.stop();
});

================
File: .env.development
================
ENVIRONMENT=development
CLOUDFLARE_ACCOUNT_ID=your_account_id
CLOUDFLARE_API_TOKEN=your_api_token

================
File: .gitignore
================
node_modules/
.env
uploads/*
!uploads/.gitkeep

================
File: jest.config.js
================
module.exports = {
    testEnvironment: 'node',
    setupFilesAfterEnv: ['<rootDir>/tests/setup.js'],
    testPathIgnorePatterns: ['/node_modules/', '/dist/'],
    verbose: true,
    collectCoverage: true,
    coverageDirectory: 'coverage',
    coveragePathIgnorePatterns: [
      '/node_modules/',
      '/tests/setup.js',
      '/tests/helpers/'
    ]
  };

================
File: package.json
================
{
  "name": "backend",
  "version": "1.0.0",
  "main": "index.js",
  "scripts": {
    "worker:dev": "wrangler dev --env dev",
    "worker:deploy": "wrangler deploy",
    "worker:deploy:dev": "wrangler deploy --env dev",
    "db:migrate": "wrangler d1 execute DB --file=./src/schema.sql",
    "db:migrate:dev": "wrangler d1 execute DB --env dev --file=./src/schema.sql"
  },
  "dependencies": {
    "itty-router": "^4.0.0"
  },
  "devDependencies": {
    "wrangler": "^3.22.1",
    "@cloudflare/workers-types": "^4.20240117.0"
  }
}

================
File: server.js
================
const express = require('express');
const mongoose = require('mongoose');
const cors = require('cors');
const path = require('path');
require('dotenv').config();

const app = express();

// Routes
app.use('/api/events', require('./routes/events'));

// Error handling middleware
app.use((err, req, res, next) => {
  console.error(err.stack);
  res.status(500).json({ message: 'Something went wrong!' });
});

// 将数据库连接和服务器启动分离
const connectDB = async () => {
  try {
    await mongoose.connect('mongodb://127.0.0.1:27017/events_db');
    console.log('Connected to MongoDB');
  } catch (err) {
    console.error('MongoDB connection error:', err);
    process.exit(1);
  }
};

// 仅在直接运行时才启动服务器
if (process.env.NODE_ENV !== 'test') {
  connectDB();
  const PORT = process.env.PORT || 5001;
  app.listen(PORT, () => {
    console.log(`Server running on port ${PORT}`);
  });
}

module.exports = { app, connectDB };

================
File: wrangler.toml
================
name = "event-api"
main = "src/index.js"
compatibility_date = "2024-01-28"

# Production environment
[vars]
ENVIRONMENT = "production"
CLOUDFLARE_ACCOUNT_ID = ""

[[d1_databases]]
binding = "DB"
database_name = "event-db"
database_id = "dba64ea5-dae4-4ed9-8ad1-6ff3bd25b263"

# Development environment
[env.dev]
name = "event-api-dev"

[env.dev.vars]
ENVIRONMENT = "development"
CLOUDFLARE_ACCOUNT_ID = "6ef191c25141298c09bb2f0d926dce50"

[[env.dev.d1_databases]]
binding = "DB"
database_name = "event-db-dev"
database_id = "c132d90d-402f-4db7-9c42-f79347bf6988"
