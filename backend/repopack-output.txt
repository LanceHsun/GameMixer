This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repopack on: 2025-02-12T05:37:24.465Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repopack, visit: https://github.com/yamadashy/repopack

================================================================
Repository Structure
================================================================
src/
  handlers/
    adminAuthHandler.js
    contactHandler.js
    donationsHandler.js
    eventsHandler.js
  services/
    emailService.js
package.json
serverless.yml

================================================================
Repository Files
================================================================

================
File: src/handlers/adminAuthHandler.js
================
// src/handlers/adminAuthHandler.js
const { 
    CognitoIdentityProviderClient, 
    AdminCreateUserCommand, 
    AdminInitiateAuthCommand,
    AdminSetUserPasswordCommand,
    AdminGetUserCommand
  } = require('@aws-sdk/client-cognito-identity-provider');
  
  const cognitoClient = new CognitoIdentityProviderClient();
  
  /**
   * 处理管理员登录
   */
  exports.handleLogin = async (event) => {
    try {
      const { username, password } = JSON.parse(event.body);
  
      // 验证必填字段
      if (!username || !password) {
        return {
          statusCode: 400,
          headers: {
            'Access-Control-Allow-Origin': '*',
            'Access-Control-Allow-Credentials': true,
          },
          body: JSON.stringify({
            message: 'Username and password are required',
          }),
        };
      }
  
      // 调用 Cognito 进行身份验证
      const authResponse = await cognitoClient.send(new AdminInitiateAuthCommand({
        AuthFlow: 'ADMIN_USER_PASSWORD_AUTH',
        ClientId: process.env.COGNITO_CLIENT_ID,
        UserPoolId: process.env.COGNITO_USER_POOL_ID,
        AuthParameters: {
          USERNAME: username,
          PASSWORD: password,
        },
      }));
  
      return {
        statusCode: 200,
        headers: {
          'Access-Control-Allow-Origin': '*',
          'Access-Control-Allow-Credentials': true,
        },
        body: JSON.stringify({
          message: 'Login successful',
          token: authResponse.AuthenticationResult.IdToken,
          refreshToken: authResponse.AuthenticationResult.RefreshToken,
          expiresIn: authResponse.AuthenticationResult.ExpiresIn,
        }),
      };
    } catch (error) {
      console.error('Login error:', error);
      return {
        statusCode: error.name === 'NotAuthorizedException' ? 401 : 500,
        headers: {
          'Access-Control-Allow-Origin': '*',
          'Access-Control-Allow-Credentials': true,
        },
        body: JSON.stringify({
          message: error.name === 'NotAuthorizedException' 
            ? 'Invalid username or password' 
            : 'Error processing login request',
          error: error.message,
        }),
      };
    }
  };
  
  /**
   * 创建新管理员用户
   * 需要管理员权限
   */
  exports.handleCreateUser = async (event) => {
    try {
      const { username, email, temporaryPassword } = JSON.parse(event.body);
  
      // 验证必填字段
      if (!username || !email || !temporaryPassword) {
        return {
          statusCode: 400,
          headers: {
            'Access-Control-Allow-Origin': '*',
            'Access-Control-Allow-Credentials': true,
          },
          body: JSON.stringify({
            message: 'Username, email and temporary password are required',
          }),
        };
      }
  
      // 验证邮箱格式
      const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
      if (!emailRegex.test(email)) {
        return {
          statusCode: 400,
          headers: {
            'Access-Control-Allow-Origin': '*',
            'Access-Control-Allow-Credentials': true,
          },
          body: JSON.stringify({
            message: 'Invalid email format',
          }),
        };
      }
  
      // 创建用户
      await cognitoClient.send(new AdminCreateUserCommand({
        UserPoolId: process.env.COGNITO_USER_POOL_ID,
        Username: username,
        UserAttributes: [
          {
            Name: 'email',
            Value: email,
          },
          {
            Name: 'email_verified',
            Value: 'true',
          },
        ],
        TemporaryPassword: temporaryPassword,
        MessageAction: 'SUPPRESS', // 不发送邮件通知
      }));
  
      // 设置永久密码
    await cognitoClient.send(new AdminSetUserPasswordCommand({
        UserPoolId: process.env.COGNITO_USER_POOL_ID,
        Username: username,
        Password: temporaryPassword,
        Permanent: true,
      }));
  
      return {
        statusCode: 200,
        headers: {
          'Access-Control-Allow-Origin': '*',
          'Access-Control-Allow-Credentials': true,
        },
        body: JSON.stringify({
          message: 'Admin user created successfully',
          username,
          email,
        }),
      };
    } catch (error) {
      console.error('Create user error:', error);
      return {
        statusCode: error.name === 'UsernameExistsException' ? 409 : 500,
        headers: {
          'Access-Control-Allow-Origin': '*',
          'Access-Control-Allow-Credentials': true,
        },
        body: JSON.stringify({
          message: error.name === 'UsernameExistsException'
            ? 'Username already exists'
            : 'Error creating admin user',
          error: error.message,
        }),
      };
    }
  };
  
  /**
   * 获取当前管理员信息
   * 需要管理员权限
   */
  exports.getCurrentUser = async (event) => {
    try {
      // 从授权头中获取用户名
      const username = event.requestContext.authorizer.claims['cognito:username'];
  
      // 获取用户详细信息
      const userResponse = await cognitoClient.send(new AdminGetUserCommand({
        UserPoolId: process.env.COGNITO_USER_POOL_ID,
        Username: username,
      }));
  
      // 从用户属性中提取邮箱
      const email = userResponse.UserAttributes.find(attr => attr.Name === 'email')?.Value;
  
      return {
        statusCode: 200,
        headers: {
          'Access-Control-Allow-Origin': '*',
          'Access-Control-Allow-Credentials': true,
        },
        body: JSON.stringify({
          username: userResponse.Username,
          email,
          created: userResponse.UserCreateDate,
          lastModified: userResponse.UserLastModifiedDate,
          enabled: userResponse.Enabled,
          status: userResponse.UserStatus,
        }),
      };
    } catch (error) {
      console.error('Get user error:', error);
      return {
        statusCode: error.name === 'UserNotFoundException' ? 404 : 500,
        headers: {
          'Access-Control-Allow-Origin': '*',
          'Access-Control-Allow-Credentials': true,
        },
        body: JSON.stringify({
          message: error.name === 'UserNotFoundException'
            ? 'User not found'
            : 'Error getting user information',
          error: error.message,
        }),
      };
    }
  };

================
File: src/handlers/contactHandler.js
================
// src/handlers/contactHandler.js
const { DynamoDBClient } = require('@aws-sdk/client-dynamodb');
const { DynamoDBDocumentClient, PutCommand } = require('@aws-sdk/lib-dynamodb');
const { v4: uuidv4 } = require('uuid');
const emailService = require('../services/emailService');

const ddbClient = new DynamoDBClient();
const ddbDocClient = DynamoDBDocumentClient.from(ddbClient);

const VALID_CATEGORIES = [
  'Sponsors and Partners',
  'Donation',
  'Membership',
  'Volunteers',
  'Other'
];

exports.submitContact = async (event) => {
  try {
    const body = JSON.parse(event.body);
    const { name, email, message, category } = body;
    
    // 验证必填字段
    if (!name || !email || !message) {
      return {
        statusCode: 400,
        headers: {
          'Access-Control-Allow-Origin': '*',
          'Access-Control-Allow-Credentials': true,
        },
        body: JSON.stringify({
          message: 'Missing required fields',
          missingFields: Object.entries({ name, email, message })
            .filter(([, value]) => !value)
            .map(([key]) => key)
        }),
      };
    }

    // 验证邮箱格式
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (!emailRegex.test(email)) {
      return {
        statusCode: 400,
        headers: {
          'Access-Control-Allow-Origin': '*',
          'Access-Control-Allow-Credentials': true,
        },
        body: JSON.stringify({
          message: 'Invalid email format'
        }),
      };
    }

    // 验证分类
    if (category && !VALID_CATEGORIES.includes(category)) {
      return {
        statusCode: 400,
        headers: {
          'Access-Control-Allow-Origin': '*',
          'Access-Control-Allow-Credentials': true,
        },
        body: JSON.stringify({
          message: 'Invalid category',
          validCategories: VALID_CATEGORIES
        }),
      };
    }
    
    // 生成联系ID
    const contactId = uuidv4();
    
    // 创建联系记录
    const contactItem = {
      id: contactId,
      email,
      name,
      message,
      category: category || 'Other',
      createdAt: new Date().toISOString(),
      type: 'CONTACT'
    };

    // 保存到数据库
    await ddbDocClient.send(new PutCommand({
      TableName: process.env.TABLE_NAME,
      Item: contactItem,
    }));

    // 发送邮件通知
    await Promise.all([
      emailService.sendContactConfirmation(name, email, category, message),
      emailService.sendContactNotification(name, email, category, message)
    ]);

    return {
      statusCode: 200,
      headers: {
        'Access-Control-Allow-Origin': '*',
        'Access-Control-Allow-Credentials': true,
      },
      body: JSON.stringify({
        message: 'Contact form submitted successfully',
        id: contactId,
      }),
    };
  } catch (error) {
    console.error('Error processing contact form:', error);
    return {
      statusCode: 500,
      headers: {
        'Access-Control-Allow-Origin': '*',
        'Access-Control-Allow-Credentials': true,
      },
      body: JSON.stringify({
        message: 'Error processing contact form submission',
        error: error.message,
      }),
    };
  }
};

================
File: src/handlers/donationsHandler.js
================
// src/handlers/donationsHandler.js
const { DynamoDBClient } = require('@aws-sdk/client-dynamodb');
const { DynamoDBDocumentClient, PutCommand, GetCommand } = require('@aws-sdk/lib-dynamodb');
const { v4: uuidv4 } = require('uuid');
const emailService = require('../services/emailService');

const ddbClient = new DynamoDBClient();
const ddbDocClient = DynamoDBDocumentClient.from(ddbClient);

// 处理现金捐赠
exports.handleMonetaryDonation = async (event) => {
  try {
    const body = JSON.parse(event.body);
    const { 
      amount,           // 捐赠金额
      contactEmail,     // 联系邮箱
      paymentMethod = 'ZELLE'  // 支付方式，目前固定为 ZELLE
    } = body;

    // 验证必填字段
    if (!amount || !contactEmail) {
      return {
        statusCode: 400,
        headers: {
          'Access-Control-Allow-Origin': '*',
          'Access-Control-Allow-Credentials': true,
        },
        body: JSON.stringify({
          message: 'Missing required fields',
          missingFields: Object.entries({ amount, contactEmail })
            .filter(([, value]) => !value)
            .map(([key]) => key)
        }),
      };
    }

    // 验证邮箱格式
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (!emailRegex.test(contactEmail)) {
      return {
        statusCode: 400,
        headers: {
          'Access-Control-Allow-Origin': '*',
          'Access-Control-Allow-Credentials': true,
        },
        body: JSON.stringify({
          message: 'Invalid email format'
        }),
      };
    }

    const donationId = uuidv4();
    
    // 创建捐赠记录
    const donationRecord = {
      id: donationId,
      type: 'MONETARY',
      amount: parseFloat(amount),
      contactEmail,
      paymentMethod,
      status: 'PENDING',
      createdAt: new Date().toISOString()
    };

    // 保存到数据库
    await ddbDocClient.send(new PutCommand({
      TableName: process.env.TABLE_NAME,
      Item: donationRecord,
    }));

    // 发送邮件通知
    await Promise.all([
      emailService.sendMonetaryDonationInstructions(contactEmail, amount, donationId),
      emailService.sendMonetaryDonationNotification(contactEmail, amount, donationId)
    ]);

    return {
      statusCode: 200,
      headers: {
        'Access-Control-Allow-Origin': '*',
        'Access-Control-Allow-Credentials': true,
      },
      body: JSON.stringify({
        message: 'Donation initiated successfully',
        donationId,
        status: 'PENDING'
      }),
    };
  } catch (error) {
    console.error('Error processing monetary donation:', error);
    return {
      statusCode: 500,
      headers: {
        'Access-Control-Allow-Origin': '*',
        'Access-Control-Allow-Credentials': true,
      },
      body: JSON.stringify({
        message: 'Error processing donation',
        error: error.message,
      }),
    };
  }
};

// 处理物品捐赠
exports.handleGoodsDonation = async (event) => {
  try {
    const body = JSON.parse(event.body);
    const { 
      donationType,    // VENUE_SPACE, GAMES, GIFTS, OTHER
      details,         // 捐赠物品的具体描述
      contactEmail     // 联系邮箱
    } = body;

    // 验证必填字段
    if (!donationType || !details || !contactEmail) {
      return {
        statusCode: 400,
        headers: {
          'Access-Control-Allow-Origin': '*',
          'Access-Control-Allow-Credentials': true,
        },
        body: JSON.stringify({
          message: 'Missing required fields',
          missingFields: Object.entries({ donationType, details, contactEmail })
            .filter(([, value]) => !value)
            .map(([key]) => key)
        }),
      };
    }

    // 验证捐赠类型
    const validTypes = ['VENUE_SPACE', 'GAMES', 'GIFTS', 'OTHER'];
    if (!validTypes.includes(donationType)) {
      return {
        statusCode: 400,
        headers: {
          'Access-Control-Allow-Origin': '*',
          'Access-Control-Allow-Credentials': true,
        },
        body: JSON.stringify({
          message: 'Invalid donation type',
          validTypes
        }),
      };
    }

    // 验证邮箱格式
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (!emailRegex.test(contactEmail)) {
      return {
        statusCode: 400,
        headers: {
          'Access-Control-Allow-Origin': '*',
          'Access-Control-Allow-Credentials': true,
        },
        body: JSON.stringify({
          message: 'Invalid email format'
        }),
      };
    }

    const donationId = uuidv4();
    
    // 创建捐赠记录
    const donationRecord = {
      id: donationId,
      type: 'GOODS',
      goodsType: donationType,
      details,
      contactEmail,
      status: 'PENDING',
      createdAt: new Date().toISOString()
    };

    // 保存到数据库
    await ddbDocClient.send(new PutCommand({
      TableName: process.env.TABLE_NAME,
      Item: donationRecord,
    }));

    // 发送邮件通知
    await Promise.all([
      emailService.sendGoodsDonationConfirmation(contactEmail, donationType, details, donationId),
      emailService.sendGoodsDonationNotification(contactEmail, donationType, details, donationId)
    ]);

    return {
      statusCode: 200,
      headers: {
        'Access-Control-Allow-Origin': '*',
        'Access-Control-Allow-Credentials': true,
      },
      body: JSON.stringify({
        message: 'Donation offer received successfully',
        donationId
      }),
    };
  } catch (error) {
    console.error('Error processing goods donation:', error);
    return {
      statusCode: 500,
      headers: {
        'Access-Control-Allow-Origin': '*',
        'Access-Control-Allow-Credentials': true,
      },
      body: JSON.stringify({
        message: 'Error processing donation offer',
        error: error.message,
      }),
    };
  }
};

================
File: src/handlers/eventsHandler.js
================
// src/handlers/eventsHandler.js
const { DynamoDBClient } = require('@aws-sdk/client-dynamodb');
const { DynamoDBDocumentClient, QueryCommand, GetCommand, PutCommand, ScanCommand, DeleteCommand } = require('@aws-sdk/lib-dynamodb');
const { v4: uuidv4 } = require('uuid');

const ddbClient = new DynamoDBClient();
const ddbDocClient = DynamoDBDocumentClient.from(ddbClient);


// Get events with optional tag filter
exports.getEvents = async (event) => {
  try {
    const queryParams = event.queryStringParameters || {};
    const tag = queryParams.tag;
    const now = new Date().toISOString();

    let allEvents;
    if (tag) {
      // First scan all events
      const response = await ddbDocClient.send(new ScanCommand({
        TableName: process.env.EVENTS_TABLE
      }));
      
      // Filter events that contain the specified tag
      allEvents = (response.Items || []).filter(event => 
        event.tags && Array.isArray(event.tags) && event.tags.includes(tag)
      );
    } else {
      // If no tag, get all events
      const response = await ddbDocClient.send(new ScanCommand({
        TableName: process.env.EVENTS_TABLE
      }));
      allEvents = response.Items || [];
    }

    // Split events into upcoming and past
    const upcomingEvents = [];
    const pastEvents = [];

    allEvents.forEach(event => {
      if (event.startTime > now) {
        upcomingEvents.push(event);
      } else {
        pastEvents.push(event);
      }
    });

    // Sort events by start time
    upcomingEvents.sort((a, b) => a.startTime.localeCompare(b.startTime));
    pastEvents.sort((a, b) => b.startTime.localeCompare(a.startTime)); // Past events in reverse order

    // Process events to add duration and format times
    const processEvents = (events) => {
      return events.map(event => ({
        ...event,
        duration: calculateDuration(event.startTime, event.endTime),
        formattedStartTime: formatDateTime(event.startTime),
        formattedEndTime: formatDateTime(event.endTime)
      }));
    };

    return {
      statusCode: 200,
      headers: {
        'Access-Control-Allow-Origin': '*',
        'Access-Control-Allow-Credentials': true,
      },
      body: JSON.stringify({
        upcoming: processEvents(upcomingEvents),
        past: processEvents(pastEvents)
      })
    };
  } catch (error) {
    console.error('Error fetching events:', error);
    return {
      statusCode: 500,
      headers: {
        'Access-Control-Allow-Origin': '*',
        'Access-Control-Allow-Credentials': true,
      },
      body: JSON.stringify({
        message: 'Error fetching events',
        error: error.message
      })
    };
  }
};

// Get all available tags
exports.getTags = async () => {
  try {
    const response = await ddbDocClient.send(new ScanCommand({
      TableName: process.env.EVENTS_TABLE,
      ProjectionExpression: 'tags'
    }));

    // Collect unique tags
    const uniqueTags = new Set();
    response.Items.forEach(event => {
      if (event.tags && Array.isArray(event.tags)) {
        event.tags.forEach(tag => uniqueTags.add(tag));
      }
    });

    return {
      statusCode: 200,
      headers: {
        'Access-Control-Allow-Origin': '*',
        'Access-Control-Allow-Credentials': true,
      },
      body: JSON.stringify({
        tags: Array.from(uniqueTags)
      })
    };
  } catch (error) {
    console.error('Error fetching tags:', error);
    return {
      statusCode: 500,
      headers: {
        'Access-Control-Allow-Origin': '*',
        'Access-Control-Allow-Credentials': true,
      },
      body: JSON.stringify({
        message: 'Error fetching tags',
        error: error.message
      })
    };
  }
};

// Get single event details
exports.getEventDetails = async (event) => {
  try {
    const eventId = event.pathParameters.id;

    const { Item: eventDetails } = await ddbDocClient.send(new GetCommand({
      TableName: process.env.EVENTS_TABLE,
      Key: { id: eventId }
    }));

    if (!eventDetails) {
      return {
        statusCode: 404,
        headers: {
          'Access-Control-Allow-Origin': '*',
          'Access-Control-Allow-Credentials': true,
        },
        body: JSON.stringify({
          message: 'Event not found'
        })
      };
    }

    // Format dates and calculate duration
    const formattedEvent = {
      ...eventDetails,
      duration: calculateDuration(eventDetails.startTime, eventDetails.endTime),
      formattedStartTime: formatDateTime(eventDetails.startTime),
      formattedEndTime: formatDateTime(eventDetails.endTime)
    };

    return {
      statusCode: 200,
      headers: {
        'Access-Control-Allow-Origin': '*',
        'Access-Control-Allow-Credentials': true,
      },
      body: JSON.stringify(formattedEvent)
    };
  } catch (error) {
    console.error('Error fetching event details:', error);
    return {
      statusCode: 500,
      headers: {
        'Access-Control-Allow-Origin': '*',
        'Access-Control-Allow-Credentials': true,
      },
      body: JSON.stringify({
        message: 'Error fetching event details',
        error: error.message
      })
    };
  }
};

// Create new event
exports.createEvent = async (event) => {
  try {
    const body = JSON.parse(event.body);
    const {
      title,
      description,
      subtitle,
      mainPicture,
      pictures,
      startTime,
      endTime,
      location,
      tags,
      video,
      links
    } = body;

    // Validate required fields
    if (!title || !startTime || !endTime) {
      return {
        statusCode: 400,
        headers: {
          'Access-Control-Allow-Origin': '*',
          'Access-Control-Allow-Credentials': true,
        },
        body: JSON.stringify({
          message: 'Missing required fields',
          required: ['title', 'startTime', 'endTime']
        })
      };
    }

    const eventId = uuidv4();
    const timestamp = new Date().toISOString();

    const newEvent = {
      id: eventId,
      title,
      description,
      subtitle,
      mainPicture,
      pictures: pictures || [],
      startTime,
      endTime,
      location,
      tags: tags || [],
      video,
      links: links || {},
      createdAt: timestamp,
      updatedAt: timestamp
    };

    await ddbDocClient.send(new PutCommand({
      TableName: process.env.EVENTS_TABLE,
      Item: newEvent
    }));

    return {
      statusCode: 200,
      headers: {
        'Access-Control-Allow-Origin': '*',
        'Access-Control-Allow-Credentials': true,
      },
      body: JSON.stringify({
        message: 'Event created successfully',
        event: newEvent
      })
    };
  } catch (error) {
    console.error('Error creating event:', error);
    return {
      statusCode: 500,
      headers: {
        'Access-Control-Allow-Origin': '*',
        'Access-Control-Allow-Credentials': true,
      },
      body: JSON.stringify({
        message: 'Error creating event',
        error: error.message
      })
    };
  }
};

// Helper function to calculate duration
const calculateDuration = (startTime, endTime) => {
  const start = new Date(startTime);
  const end = new Date(endTime);
  const diffMs = end - start;
  const diffHrs = Math.floor(diffMs / (1000 * 60 * 60));
  const diffMins = Math.floor((diffMs % (1000 * 60 * 60)) / (1000 * 60));
  
  return {
    hours: diffHrs,
    minutes: diffMins
  };
};

// Helper function to format date time
const formatDateTime = (dateTimeStr) => {
  const date = new Date(dateTimeStr);
  return {
    year: date.getFullYear(),
    month: date.getMonth() + 1,
    day: date.getDate(),
    hour: date.getHours(),
    minute: date.getMinutes()
  };
};

// Update event
exports.updateEvent = async (event) => {
  try {
    const eventId = event.pathParameters.id;
    const body = JSON.parse(event.body);
    const {
      title,
      description,
      subtitle,
      mainPicture,
      pictures,
      startTime,
      endTime,
      location,
      tags,
      video,
      links
    } = body;

    // Validate required fields
    if (!title || !startTime || !endTime) {
      return {
        statusCode: 400,
        headers: {
          'Access-Control-Allow-Origin': '*',
          'Access-Control-Allow-Credentials': true,
        },
        body: JSON.stringify({
          message: 'Missing required fields',
          required: ['title', 'startTime', 'endTime']
        })
      };
    }

    // Check if event exists
    const { Item: existingEvent } = await ddbDocClient.send(new GetCommand({
      TableName: process.env.EVENTS_TABLE,
      Key: { id: eventId }
    }));

    if (!existingEvent) {
      return {
        statusCode: 404,
        headers: {
          'Access-Control-Allow-Origin': '*',
          'Access-Control-Allow-Credentials': true,
        },
        body: JSON.stringify({
          message: 'Event not found'
        })
      };
    }

    const updatedEvent = {
      ...existingEvent,
      title,
      description,
      subtitle,
      mainPicture,
      pictures: pictures || [],
      startTime,
      endTime,
      location,
      tags: tags || [],
      video,
      links: links || {},
      updatedAt: new Date().toISOString()
    };

    await ddbDocClient.send(new PutCommand({
      TableName: process.env.EVENTS_TABLE,
      Item: updatedEvent
    }));

    return {
      statusCode: 200,
      headers: {
        'Access-Control-Allow-Origin': '*',
        'Access-Control-Allow-Credentials': true,
      },
      body: JSON.stringify({
        message: 'Event updated successfully',
        event: updatedEvent
      })
    };
  } catch (error) {
    console.error('Error updating event:', error);
    return {
      statusCode: 500,
      headers: {
        'Access-Control-Allow-Origin': '*',
        'Access-Control-Allow-Credentials': true,
      },
      body: JSON.stringify({
        message: 'Error updating event',
        error: error.message
      })
    };
  }
};

// Delete event
exports.deleteEvent = async (event) => {
  try {
    const eventId = event.pathParameters.id;

    // Check if event exists
    const { Item: existingEvent } = await ddbDocClient.send(new GetCommand({
      TableName: process.env.EVENTS_TABLE,
      Key: { id: eventId }
    }));

    if (!existingEvent) {
      return {
        statusCode: 404,
        headers: {
          'Access-Control-Allow-Origin': '*',
          'Access-Control-Allow-Credentials': true,
        },
        body: JSON.stringify({
          message: 'Event not found'
        })
      };
    }

    await ddbDocClient.send(new DeleteCommand({
      TableName: process.env.EVENTS_TABLE,
      Key: { id: eventId }
    }));

    return {
      statusCode: 200,
      headers: {
        'Access-Control-Allow-Origin': '*',
        'Access-Control-Allow-Credentials': true,
      },
      body: JSON.stringify({
        message: 'Event deleted successfully',
        id: eventId
      })
    };
  } catch (error) {
    console.error('Error deleting event:', error);
    return {
      statusCode: 500,
      headers: {
        'Access-Control-Allow-Origin': '*',
        'Access-Control-Allow-Credentials': true,
      },
      body: JSON.stringify({
        message: 'Error deleting event',
        error: error.message
      })
    };
  }
};

================
File: src/services/emailService.js
================
// src/services/emailService.js
const { SESClient, SendEmailCommand } = require('@aws-sdk/client-ses');
const sesClient = new SESClient();

class EmailService {
  constructor(senderEmail) {
    this.senderEmail = senderEmail;
  }

  // 基础邮件发送方法
  async sendEmail(to, subject, body) {
    const params = {
      Source: this.senderEmail,
      Destination: {
        ToAddresses: Array.isArray(to) ? to : [to],
      },
      Message: {
        Subject: { Data: subject },
        Body: { Text: { Data: body } },
      },
    };

    try {
      await sesClient.send(new SendEmailCommand(params));
    } catch (error) {
      console.error('Error sending email:', error);
      throw new Error('Failed to send email: ' + error.message);
    }
  }

  // Contact Form 相关邮件
  async sendContactConfirmation(name, email, category, message) {
    const subject = category 
      ? `Thank you for contacting Game Mixer - ${category}`
      : 'Thank you for contacting Game Mixer';

    const body = `Dear ${name},

Thank you for contacting us${category ? ` regarding ${category}` : ''}. We have received your message and will get back to you soon.

Your message:
${message}

Best regards,
Game Mixer Team`;

    await this.sendEmail(email, subject, body);
  }

  async sendContactNotification(name, email, category, message) {
    const subject = `New Contact Form Submission - ${category || 'General'}`;

    const body = `New contact form submission received:

From: ${name}
Email: ${email}
Category: ${category || 'Not specified'}

Message:
${message}

Action Required:
Please review and respond to this inquiry within 24 hours.

Note: Timely response helps maintain good communication with our community.`;

    await this.sendEmail(this.senderEmail, subject, body);
  }

  // Monetary Donation 相关邮件
  async sendMonetaryDonationInstructions(email, amount, donationId) {
    const subject = 'Game Mixer - Donation Payment Instructions';
    const body = `Dear Donor,

Thank you for your generous donation of $${amount}! Please follow these steps to complete your donation:

1. Open your Zelle app or banking app with Zelle
2. Send payment to: ${this.senderEmail}
3. Amount to send: $${amount}
4. Important: Include this Donation ID in the memo: ${donationId}

Once you’ve completed the payment, we will send you a donation receipt. If you do not receive the receipt within 24 hours of a successful payment, please contact us again at ${this.senderEmail}

Thank you for supporting Game Mixer!

Best regards,
Game Mixer Team`;

    await this.sendEmail(email, subject, body);
  }

  async sendMonetaryDonationNotification(email, amount, donationId) {
    const subject = 'New Monetary Donation Received';
    const body = `New monetary donation initiated:

Amount: $${amount}
Contact Email: ${email}
Donation ID: ${donationId}
Status: PENDING

IMPORTANT ACTION REQUIRED:
1. Please check your Zelle account for the incoming payment of $${amount}
2. Once payment is received, please verify the donation and send a receipt to the donor
3. Use the Donation ID above when verifying the payment

Note: Timely verification helps maintain donor trust.`;

    await this.sendEmail(this.senderEmail, subject, body);
  }

  // Goods Donation 相关邮件
  async sendGoodsDonationConfirmation(email, donationType, details, donationId) {
    const subject = 'Thank You for Your Donation Offer';
    const body = `Dear Donor,

Thank you for your generous donation offer! We have received your submission and will contact you soon to discuss the details.

Donation Details:
Type: ${donationType}
Description: ${details}

Reference Number: ${donationId}

We greatly appreciate your support and will be in touch shortly!

Best regards,
Game Mixer Team`;

    await this.sendEmail(email, subject, body);
  }

  async sendGoodsDonationNotification(email, donationType, details, donationId) {
    const subject = 'New Goods Donation Offer Received';
    const body = `New goods donation offer received:

Type: ${donationType}
Description: ${details}
Contact Email: ${email}
Donation ID: ${donationId}

Action Required:
Please contact the donor within 24 hours to discuss:
- Verify item condition and specifications
- Arrange logistics for collection/delivery
- Confirm acceptance of donation

Next Steps:
1. Review donation details
2. Contact donor within 24 hours`;

    await this.sendEmail(this.senderEmail, subject, body);
  }
}

// 导出单例实例
const emailService = new EmailService(process.env.SENDER_EMAIL);
module.exports = emailService;

================
File: package.json
================
{
  "name": "game-mixer-backend",
  "version": "1.0.0",
  "description": "Game Mixer Backend Services",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "deploy": "serverless deploy"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "dependencies": {
    "@aws-sdk/client-dynamodb": "^3.741.0",
    "@aws-sdk/client-ses": "^3.741.0",
    "@aws-sdk/lib-dynamodb": "^3.741.0",
    "aws-sdk": "^2.1692.0",
    "uuid": "^11.0.5"
  },
  "devDependencies": {
    "esbuild": "^0.24.2",
    "serverless": "^4.6.0"
  }
}

================
File: serverless.yml
================
service: game-mixer-backend

frameworkVersion: '4'

custom:
  tableName: ${self:service}-${sls:stage}
  eventsTableName: ${self:service}-events-${sls:stage}
  adminUserPoolName: ${self:service}-admin-pool-${sls:stage}

provider:
  name: aws
  runtime: nodejs18.x
  stage: ${opt:stage, 'dev'}
  region: ${opt:region, 'us-west-2'}
  environment:
    SENDER_EMAIL: ${env:SENDER_EMAIL}
    TABLE_NAME: ${self:custom.tableName}
    EVENTS_TABLE: ${self:custom.eventsTableName}
    COGNITO_USER_POOL_ID: !Ref AdminUserPool
    COGNITO_CLIENT_ID: !Ref AdminUserPoolClient
  logRetentionInDays: 14
  apiGateway:
    minimumCompressionSize: 1024
    shouldStartNameWithService: true
  iam:
    role:
      statements:
        - Effect: Allow
          Action:
            - cognito-idp:AdminInitiateAuth
            - cognito-idp:AdminCreateUser
            - cognito-idp:AdminSetUserPassword
            - cognito-idp:AdminGetUser
          Resource: !GetAtt AdminUserPool.Arn
        - Effect: Allow
          Action:
            - ses:SendEmail
            - ses:SendRawEmail
          Resource: "*"
        - Effect: Allow
          Action:
            - dynamodb:PutItem
            - dynamodb:GetItem
            - dynamodb:Query
            - dynamodb:Scan
            - dynamodb:UpdateItem
            - dynamodb:DeleteItem
          Resource: 
            - "arn:aws:dynamodb:${aws:region}:${aws:accountId}:table/${self:provider.environment.TABLE_NAME}"
            - "arn:aws:dynamodb:${aws:region}:${aws:accountId}:table/${self:provider.environment.TABLE_NAME}/index/*"
            - "arn:aws:dynamodb:${aws:region}:${aws:accountId}:table/${self:provider.environment.EVENTS_TABLE}"
            - "arn:aws:dynamodb:${aws:region}:${aws:accountId}:table/${self:provider.environment.EVENTS_TABLE}/index/*"
        - Effect: Allow
          Action:
            - logs:CreateLogGroup
            - logs:CreateLogStream
            - logs:PutLogEvents
          Resource: "*"

functions:
  # Admin Auth Functions
  adminLogin:
    handler: src/handlers/adminAuthHandler.handleLogin
    events:
      - http:
          path: admin/login
          method: post
          cors: true

  adminCreateUser:
    handler: src/handlers/adminAuthHandler.handleCreateUser
    events:
      - http:
          path: admin/users
          method: post
          cors: true
          authorizer:
            name: adminAuthorizer
            type: COGNITO_USER_POOLS
            arn: !GetAtt AdminUserPool.Arn

  getCurrentAdmin:
    handler: src/handlers/adminAuthHandler.getCurrentUser
    events:
      - http:
          path: admin/me
          method: get
          cors: true
          authorizer:
            name: adminAuthorizer
            type: COGNITO_USER_POOLS
            arn: !GetAtt AdminUserPool.Arn

  # Contact Form Handler
  submitContact:
    handler: src/handlers/contactHandler.submitContact
    events:
      - http:
          path: contact
          method: post
          cors: true
    memorySize: 256
    timeout: 29

  # Donation Handlers
  submitMonetaryDonation:
    handler: src/handlers/donationsHandler.handleMonetaryDonation
    events:
      - http:
          path: donations/monetary
          method: post
          cors: true
    memorySize: 256
    timeout: 29

  submitGoodsDonation:
    handler: src/handlers/donationsHandler.handleGoodsDonation
    events:
      - http:
          path: donations/goods
          method: post
          cors: true
    memorySize: 256
    timeout: 29

  # Event Handlers - Public
  getEvents:
    handler: src/handlers/eventsHandler.getEvents
    events:
      - http:
          path: events
          method: get
          cors: true
    memorySize: 256
    timeout: 29

  getEventDetails:
    handler: src/handlers/eventsHandler.getEventDetails
    events:
      - http:
          path: events/{id}
          method: get
          cors: true
    memorySize: 256
    timeout: 29

  getTags:
    handler: src/handlers/eventsHandler.getTags
    events:
      - http:
          path: events/tags
          method: get
          cors: true
    memorySize: 256
    timeout: 29

  # Event Handlers - Admin
  createEvent:
    handler: src/handlers/eventsHandler.createEvent
    events:
      - http:
          path: admin/events
          method: post
          cors: true
          authorizer:
            name: adminAuthorizer
            type: COGNITO_USER_POOLS
            arn: !GetAtt AdminUserPool.Arn
    memorySize: 256
    timeout: 29

  updateEvent:
    handler: src/handlers/eventsHandler.updateEvent
    events:
      - http:
          path: admin/events/{id}
          method: put
          cors: true
          authorizer:
            name: adminAuthorizer
            type: COGNITO_USER_POOLS
            arn: !GetAtt AdminUserPool.Arn
    memorySize: 256
    timeout: 29

  deleteEvent:
    handler: src/handlers/eventsHandler.deleteEvent
    events:
      - http:
          path: admin/events/{id}
          method: delete
          cors: true
          authorizer:
            name: adminAuthorizer
            type: COGNITO_USER_POOLS
            arn: !GetAtt AdminUserPool.Arn
    memorySize: 256
    timeout: 29

resources:
  Resources:
    # Admin Cognito Resources
    AdminUserPool:
      Type: AWS::Cognito::UserPool
      Properties:
        UserPoolName: ${self:custom.adminUserPoolName}
        AdminCreateUserConfig:
          AllowAdminCreateUserOnly: true
        Policies:
          PasswordPolicy:
            MinimumLength: 8
            RequireLowercase: true
            RequireNumbers: true
            RequireSymbols: true
            RequireUppercase: true
        Schema:
          - Name: email
            Required: true
            Mutable: true
            AttributeDataType: String

    AdminUserPoolClient:
      Type: AWS::Cognito::UserPoolClient
      Properties:
        UserPoolId: !Ref AdminUserPool
        ClientName: ${self:service}-admin-client-${sls:stage}
        GenerateSecret: false
        ExplicitAuthFlows:
          - ALLOW_ADMIN_USER_PASSWORD_AUTH
          - ALLOW_REFRESH_TOKEN_AUTH

    # DynamoDB Tables
    DonationsTable:
      Type: AWS::DynamoDB::Table
      DeletionPolicy: Retain
      Properties:
        TableName: ${self:custom.tableName}
        AttributeDefinitions:
          - AttributeName: id
            AttributeType: S
          - AttributeName: type
            AttributeType: S
          - AttributeName: status
            AttributeType: S
          - AttributeName: contactEmail
            AttributeType: S
          - AttributeName: createdAt
            AttributeType: S
        KeySchema:
          - AttributeName: id
            KeyType: HASH
        GlobalSecondaryIndexes:
          - IndexName: typeIndex
            KeySchema:
              - AttributeName: type
                KeyType: HASH
              - AttributeName: createdAt
                KeyType: RANGE
            Projection:
              ProjectionType: ALL
          - IndexName: statusIndex
            KeySchema:
              - AttributeName: status
                KeyType: HASH
              - AttributeName: createdAt
                KeyType: RANGE
            Projection:
              ProjectionType: ALL
          - IndexName: emailIndex
            KeySchema:
              - AttributeName: contactEmail
                KeyType: HASH
              - AttributeName: createdAt
                KeyType: RANGE
            Projection:
              ProjectionType: ALL
        BillingMode: PAY_PER_REQUEST
        TimeToLiveSpecification:
          AttributeName: ttl
          Enabled: true
        Tags:
          - Key: Environment
            Value: ${self:provider.stage}

    EventsTable:
      Type: AWS::DynamoDB::Table
      DeletionPolicy: Retain
      Properties:
        TableName: ${self:custom.eventsTableName}
        AttributeDefinitions:
          - AttributeName: id
            AttributeType: S
          - AttributeName: startTime
            AttributeType: S
          - AttributeName: tag
            AttributeType: S
        KeySchema:
          - AttributeName: id
            KeyType: HASH
        GlobalSecondaryIndexes:
          - IndexName: startTimeIndex
            KeySchema:
              - AttributeName: startTime
                KeyType: HASH
            Projection:
              ProjectionType: ALL
          - IndexName: tagIndex
            KeySchema:
              - AttributeName: tag
                KeyType: HASH
            Projection:
              ProjectionType: ALL
        BillingMode: PAY_PER_REQUEST
        TimeToLiveSpecification:
          AttributeName: ttl
          Enabled: true
        Tags:
          - Key: Environment
            Value: ${self:provider.stage}

    GatewayResponseDefault4XX:
      Type: 'AWS::ApiGateway::GatewayResponse'
      Properties:
        ResponseParameters:
          gatewayresponse.header.Access-Control-Allow-Origin: "'*'"
          gatewayresponse.header.Access-Control-Allow-Headers: "'*'"
        ResponseType: DEFAULT_4XX
        RestApiId:
          Ref: 'ApiGatewayRestApi'

    GatewayResponseDefault5XX:
      Type: 'AWS::ApiGateway::GatewayResponse'
      Properties:
        ResponseParameters:
          gatewayresponse.header.Access-Control-Allow-Origin: "'*'"
          gatewayresponse.header.Access-Control-Allow-Headers: "'*'"
        ResponseType: DEFAULT_5XX
        RestApiId:
          Ref: 'ApiGatewayRestApi'
