This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repopack on: 2025-02-05T05:05:51.227Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repopack, visit: https://github.com/yamadashy/repopack

================================================================
Repository Structure
================================================================
src/
  handlers/
    contactHandler.js
    donationsHandler.js
    eventsHandler.js
    paymentHandler.js
package.json
serverless.yml

================================================================
Repository Files
================================================================

================
File: src/handlers/contactHandler.js
================
// src/handlers/contactHandler.js
const { DynamoDBClient } = require('@aws-sdk/client-dynamodb');
const { DynamoDBDocumentClient, PutCommand } = require('@aws-sdk/lib-dynamodb');
const { SESClient, SendEmailCommand } = require('@aws-sdk/client-ses');
const { v4: uuidv4 } = require('uuid');

const ddbClient = new DynamoDBClient();
const ddbDocClient = DynamoDBDocumentClient.from(ddbClient);
const sesClient = new SESClient();

exports.handler = async (event) => {
  try {
    const body = JSON.parse(event.body);
    const { name, email, message } = body;
    
    // 生成唯一ID
    const contactId = uuidv4();
    
    // 存储到DynamoDB
    const contactItem = {
      id: contactId,
      email,
      name,
      message,
      createdAt: new Date().toISOString(),
      type: 'CONTACT'
    };

    await ddbDocClient.send(new PutCommand({
      TableName: process.env.TABLE_NAME,
      Item: contactItem,
    }));

    // 发送确认邮件
    const emailParams = {
      Source: process.env.SENDER_EMAIL,
      Destination: {
        ToAddresses: [email],
      },
      Message: {
        Subject: {
          Data: 'Thank you for contacting Game Mixer',
        },
        Body: {
          Text: {
            Data: `Dear ${name},\n\nThank you for contacting us. We have received your message and will get back to you soon.\n\nBest regards,\nGame Mixer Team`,
          },
        },
      },
    };

    await sesClient.send(new SendEmailCommand(emailParams));

    return {
      statusCode: 200,
      headers: {
        'Access-Control-Allow-Origin': '*',
        'Access-Control-Allow-Credentials': true,
      },
      body: JSON.stringify({
        message: 'Contact form submitted successfully',
        id: contactId,
      }),
    };
  } catch (error) {
    console.error('Error:', error);
    return {
      statusCode: 500,
      headers: {
        'Access-Control-Allow-Origin': '*',
        'Access-Control-Allow-Credentials': true,
      },
      body: JSON.stringify({
        message: 'Error processing contact form submission',
        error: error.message,
      }),
    };
  }
};

================
File: src/handlers/donationsHandler.js
================
// src/handlers/donationHandler.js
const { DynamoDBClient } = require('@aws-sdk/client-dynamodb');
const { DynamoDBDocumentClient, PutCommand } = require('@aws-sdk/lib-dynamodb');
const { SESClient, SendEmailCommand } = require('@aws-sdk/client-ses');
const { v4: uuidv4 } = require('uuid');

const ddbClient = new DynamoDBClient();
const ddbDocClient = DynamoDBDocumentClient.from(ddbClient);
const sesClient = new SESClient();

// Handle monetary donation
exports.handleMonetaryDonation = async (event) => {
  try {
    const body = JSON.parse(event.body);
    const { 
      amount,           // 捐赠金额
      contactEmail,     // 联系邮箱
      paymentMethod = 'ZELLE'  // 支付方式，目前固定为 ZELLE
    } = body;

    // Validate required fields
    if (!amount || !contactEmail) {
      return {
        statusCode: 400,
        headers: {
          'Access-Control-Allow-Origin': '*',
          'Access-Control-Allow-Credentials': true,
        },
        body: JSON.stringify({
          message: 'Missing required fields',
          missingFields: Object.entries({ amount, contactEmail })
            .filter(([, value]) => !value)
            .map(([key]) => key)
        }),
      };
    }

    const donationId = uuidv4();
    
    // Create donation record
    const donationRecord = {
      id: donationId,
      type: 'MONETARY',
      amount: parseFloat(amount),
      contactEmail,
      paymentMethod,
      status: 'PENDING',
      createdAt: new Date().toISOString()
    };

    // Save to DynamoDB
    await ddbDocClient.send(new PutCommand({
      TableName: process.env.TABLE_NAME,
      Item: donationRecord,
    }));

    // Send payment instructions to donor
    const donorEmailParams = {
      Source: process.env.SENDER_EMAIL,
      Destination: {
        ToAddresses: [contactEmail],
      },
      Message: {
        Subject: {
          Data: 'Game Mixer - Donation Payment Instructions',
        },
        Body: {
          Text: {
            Data: `
Dear Donor,

Thank you for your generous donation of $${amount}! Please follow these steps to complete your donation:

1. Open your Zelle app or banking app with Zelle
2. Send payment to: ${process.env.SENDER_EMAIL}
3. Amount to send: $${amount}
4. Important: Include this Donation ID in the memo: ${donationId}

Once you've completed the payment, we will send you a donation receipt.

Thank you for supporting Game Mixer!

Best regards,
Game Mixer Team`,
          },
        },
      },
    };

    // Send notification to organization
    const orgEmailParams = {
      Source: process.env.SENDER_EMAIL,
      Destination: {
        ToAddresses: [process.env.SENDER_EMAIL],
      },
      Message: {
        Subject: {
          Data: 'New Monetary Donation Received',
        },
        Body: {
          Text: {
            Data: `
New monetary donation initiated:

Amount: $${amount}
Contact Email: ${contactEmail}
Payment Method: ${paymentMethod}
Donation ID: ${donationId}
Status: PENDING`,
          },
        },
      },
    };

    // Send both emails
    await Promise.all([
      sesClient.send(new SendEmailCommand(donorEmailParams)),
      sesClient.send(new SendEmailCommand(orgEmailParams))
    ]);

    return {
      statusCode: 200,
      headers: {
        'Access-Control-Allow-Origin': '*',
        'Access-Control-Allow-Credentials': true,
      },
      body: JSON.stringify({
        message: 'Donation initiated successfully',
        donationId,
        status: 'PENDING'
      }),
    };
  } catch (error) {
    console.error('Error processing donation:', error);
    return {
      statusCode: 500,
      headers: {
        'Access-Control-Allow-Origin': '*',
        'Access-Control-Allow-Credentials': true,
      },
      body: JSON.stringify({
        message: 'Error processing donation',
        error: error.message,
      }),
    };
  }
};

// Handle goods donation
exports.handleGoodsDonation = async (event) => {
  try {
    const body = JSON.parse(event.body);
    const { 
      donationType,    // VENUE_SPACE, GAMES, GIFTS, OTHER
      details,         // 捐赠物品的具体描述
      contactEmail     // 联系邮箱
    } = body;

    // Validate required fields
    if (!donationType || !details || !contactEmail) {
      return {
        statusCode: 400,
        headers: {
          'Access-Control-Allow-Origin': '*',
          'Access-Control-Allow-Credentials': true,
        },
        body: JSON.stringify({
          message: 'Missing required fields',
          missingFields: Object.entries({ donationType, details, contactEmail })
            .filter(([, value]) => !value)
            .map(([key]) => key)
        }),
      };
    }

    // Validate donation type
    const validTypes = ['VENUE_SPACE', 'GAMES', 'GIFTS', 'OTHER'];
    if (!validTypes.includes(donationType)) {
      return {
        statusCode: 400,
        headers: {
          'Access-Control-Allow-Origin': '*',
          'Access-Control-Allow-Credentials': true,
        },
        body: JSON.stringify({
          message: 'Invalid donation type',
          validTypes
        }),
      };
    }

    const donationId = uuidv4();
    
    // Create donation record
    const donationRecord = {
      id: donationId,
      type: 'GOODS',
      goodsType: donationType,
      details,
      contactEmail,
      status: 'PENDING',
      createdAt: new Date().toISOString()
    };

    // Save to DynamoDB
    await ddbDocClient.send(new PutCommand({
      TableName: process.env.TABLE_NAME,
      Item: donationRecord,
    }));

    // Send confirmation to donor
    const donorEmailParams = {
      Source: process.env.SENDER_EMAIL,
      Destination: {
        ToAddresses: [contactEmail],
      },
      Message: {
        Subject: {
          Data: 'Thank You for Your Donation Offer',
        },
        Body: {
          Text: {
            Data: `
Dear Donor,

Thank you for your generous donation offer! We have received your submission and will contact you soon to discuss the details.

Donation Details:
Type: ${donationType}
Description: ${details}

Reference Number: ${donationId}

We greatly appreciate your support and will be in touch shortly!

Best regards,
Game Mixer Team`,
          },
        },
      },
    };

    // Send notification to organization
    const orgEmailParams = {
      Source: process.env.SENDER_EMAIL,
      Destination: {
        ToAddresses: [process.env.SENDER_EMAIL],
      },
      Message: {
        Subject: {
          Data: 'New Goods Donation Offer Received',
        },
        Body: {
          Text: {
            Data: `
New goods donation offer received:

Type: ${donationType}
Description: ${details}
Contact Email: ${contactEmail}
Donation ID: ${donationId}`,
          },
        },
      },
    };

    // Send both emails
    await Promise.all([
      sesClient.send(new SendEmailCommand(donorEmailParams)),
      sesClient.send(new SendEmailCommand(orgEmailParams))
    ]);

    return {
      statusCode: 200,
      headers: {
        'Access-Control-Allow-Origin': '*',
        'Access-Control-Allow-Credentials': true,
      },
      body: JSON.stringify({
        message: 'Donation offer received successfully',
        donationId
      }),
    };
  } catch (error) {
    console.error('Error processing donation:', error);
    return {
      statusCode: 500,
      headers: {
        'Access-Control-Allow-Origin': '*',
        'Access-Control-Allow-Credentials': true,
      },
      body: JSON.stringify({
        message: 'Error processing donation offer',
        error: error.message,
      }),
    };
  }
};

================
File: src/handlers/eventsHandler.js
================
// src/handlers/eventsHandler.js
const { DynamoDBClient } = require('@aws-sdk/client-dynamodb');
const { DynamoDBDocumentClient, QueryCommand, GetCommand, PutCommand, UpdateCommand } = require('@aws-sdk/lib-dynamodb');
const { v4: uuidv4 } = require('uuid');

const ddbClient = new DynamoDBClient();
const ddbDocClient = DynamoDBDocumentClient.from(ddbClient);

// Get events with optional tag filter
exports.getEvents = async (event) => {
  try {
    const queryParams = event.queryStringParameters || {};
    const tag = queryParams.tag;
    const now = new Date().toISOString();

    // Base query parameters
    const baseParams = {
      TableName: process.env.EVENTS_TABLE,
      IndexName: 'eventDateIndex'
    };

    // If tag is provided, use tag index and filter
    if (tag) {
      baseParams.IndexName = 'tagIndex';
      baseParams.KeyConditionExpression = 'tag = :tag';
      baseParams.ExpressionAttributeValues = {
        ':tag': tag
      };
    } else {
      baseParams.IndexName = 'startTimeIndex';
    }

    // Query upcoming events
    const upcomingEvents = await ddbDocClient.send(new QueryCommand({
      ...baseParams,
      KeyConditionExpression: 'startTime > :now',
      ExpressionAttributeValues: {
        ...(baseParams.ExpressionAttributeValues || {}),
        ':now': now
      }
    }));

    // Query past events
    const pastEvents = await ddbDocClient.send(new QueryCommand({
      ...baseParams,
      KeyConditionExpression: 'startTime <= :now',
      ExpressionAttributeValues: {
        ...(baseParams.ExpressionAttributeValues || {}),
        ':now': now
      }
    }));

    // Process events to calculate duration and format times
    const processEvents = (events) => {
      return events.map(event => ({
        ...event,
        duration: calculateDuration(event.startTime, event.endTime),
        formattedStartTime: formatDateTime(event.startTime),
        formattedEndTime: formatDateTime(event.endTime)
      }));
    };

    return {
      statusCode: 200,
      headers: {
        'Access-Control-Allow-Origin': '*',
        'Access-Control-Allow-Credentials': true,
      },
      body: JSON.stringify({
        upcoming: processEvents(upcomingEvents.Items || []),
        past: processEvents(pastEvents.Items || [])
      })
    };
  } catch (error) {
    console.error('Error fetching events:', error);
    return {
      statusCode: 500,
      headers: {
        'Access-Control-Allow-Origin': '*',
        'Access-Control-Allow-Credentials': true,
      },
      body: JSON.stringify({
        message: 'Error fetching events',
        error: error.message
      })
    };
  }
};

// Get all available tags
exports.getTags = async () => {
  try {
    const { Items: events } = await ddbDocClient.send(new QueryCommand({
      TableName: process.env.EVENTS_TABLE,
      ProjectionExpression: 'tags'
    }));

    // Collect unique tags
    const uniqueTags = new Set();
    events.forEach(event => {
      if (event.tags && Array.isArray(event.tags)) {
        event.tags.forEach(tag => uniqueTags.add(tag));
      }
    });

    return {
      statusCode: 200,
      headers: {
        'Access-Control-Allow-Origin': '*',
        'Access-Control-Allow-Credentials': true,
      },
      body: JSON.stringify({
        tags: Array.from(uniqueTags)
      })
    };
  } catch (error) {
    console.error('Error fetching tags:', error);
    return {
      statusCode: 500,
      headers: {
        'Access-Control-Allow-Origin': '*',
        'Access-Control-Allow-Credentials': true,
      },
      body: JSON.stringify({
        message: 'Error fetching tags',
        error: error.message
      })
    };
  }
};

// Get single event details
exports.getEventDetails = async (event) => {
  try {
    const eventId = event.pathParameters.id;

    const { Item: eventDetails } = await ddbDocClient.send(new GetCommand({
      TableName: process.env.EVENTS_TABLE,
      Key: { id: eventId }
    }));

    if (!eventDetails) {
      return {
        statusCode: 404,
        headers: {
          'Access-Control-Allow-Origin': '*',
          'Access-Control-Allow-Credentials': true,
        },
        body: JSON.stringify({
          message: 'Event not found'
        })
      };
    }

    // Format dates and calculate duration
    const formattedEvent = {
      ...eventDetails,
      duration: calculateDuration(eventDetails.startTime, eventDetails.endTime),
      formattedStartTime: formatDateTime(eventDetails.startTime),
      formattedEndTime: formatDateTime(eventDetails.endTime)
    };

    return {
      statusCode: 200,
      headers: {
        'Access-Control-Allow-Origin': '*',
        'Access-Control-Allow-Credentials': true,
      },
      body: JSON.stringify(formattedEvent)
    };
  } catch (error) {
    console.error('Error fetching event details:', error);
    return {
      statusCode: 500,
      headers: {
        'Access-Control-Allow-Origin': '*',
        'Access-Control-Allow-Credentials': true,
      },
      body: JSON.stringify({
        message: 'Error fetching event details',
        error: error.message
      })
    };
  }
};

// Create new event
exports.createEvent = async (event) => {
  try {
    const body = JSON.parse(event.body);
    const {
      title,
      description,
      subtitle,
      mainPicture,
      pictures,
      startTime,
      endTime,
      location,
      tags,
      video,
      links
    } = body;

    const eventId = uuidv4();
    const timestamp = new Date().toISOString();

    const newEvent = {
      id: eventId,
      title,
      description,
      subtitle,
      mainPicture,
      pictures: pictures || [],
      startTime,
      endTime,
      location,
      tags: tags || [],
      video,
      links: links || {},
      createdAt: timestamp,
      updatedAt: timestamp
    };

    await ddbDocClient.send(new PutCommand({
      TableName: process.env.EVENTS_TABLE,
      Item: newEvent
    }));

    return {
      statusCode: 200,
      headers: {
        'Access-Control-Allow-Origin': '*',
        'Access-Control-Allow-Credentials': true,
      },
      body: JSON.stringify({
        message: 'Event created successfully',
        event: newEvent
      })
    };
  } catch (error) {
    console.error('Error creating event:', error);
    return {
      statusCode: 500,
      headers: {
        'Access-Control-Allow-Origin': '*',
        'Access-Control-Allow-Credentials': true,
      },
      body: JSON.stringify({
        message: 'Error creating event',
        error: error.message
      })
    };
  }
};

// Helper function to calculate duration
const calculateDuration = (startTime, endTime) => {
  const start = new Date(startTime);
  const end = new Date(endTime);
  const diffMs = end - start;
  const diffHrs = Math.floor(diffMs / (1000 * 60 * 60));
  const diffMins = Math.floor((diffMs % (1000 * 60 * 60)) / (1000 * 60));
  
  return {
    hours: diffHrs,
    minutes: diffMins
  };
};

// Helper function to format date time
const formatDateTime = (dateTimeStr) => {
  const date = new Date(dateTimeStr);
  return {
    year: date.getFullYear(),
    month: date.getMonth() + 1,
    day: date.getDate(),
    hour: date.getHours(),
    minute: date.getMinutes()
  };
};

================
File: src/handlers/paymentHandler.js
================
// src/handlers/paymentHandler.js
const { DynamoDBClient } = require('@aws-sdk/client-dynamodb');
const { DynamoDBDocumentClient, PutCommand, GetCommand } = require('@aws-sdk/lib-dynamodb');
const { SESClient, SendEmailCommand } = require('@aws-sdk/client-ses');
const { v4: uuidv4 } = require('uuid');

const ddbClient = new DynamoDBClient();
const ddbDocClient = DynamoDBDocumentClient.from(ddbClient);
const sesClient = new SESClient();

// Handle new payment request
exports.handler = async (event) => {
  console.log('Payment request received:', {
    body: event.body,
    headers: event.headers,
    requestContext: event.requestContext
  });

  try {
    const body = JSON.parse(event.body);
    console.log('Parsed request body:', body);

    const { amount, customerEmail, customerName, orderDetails } = body;
    
    // Validate required fields
    if (!amount || !customerEmail || !customerName || !orderDetails) {
      console.error('Missing required fields:', { body });
      return {
        statusCode: 400,
        headers: {
          'Access-Control-Allow-Origin': '*',
          'Access-Control-Allow-Credentials': true,
        },
        body: JSON.stringify({
          message: 'Missing required fields',
          missingFields: Object.entries({ amount, customerEmail, customerName, orderDetails })
            .filter(([, value]) => !value)
            .map(([key]) => key)
        }),
      };
    }

    // Generate unique payment ID
    const paymentId = uuidv4();
    console.log('Generated payment ID:', paymentId);
    
    // Create payment record
    const paymentRecord = {
      id: paymentId,
      amount,
      customerEmail,
      customerName,
      orderDetails,
      status: 'PENDING',
      type: 'PAYMENT',
      createdAt: new Date().toISOString(),
    };
    
    console.log('Saving payment record to DynamoDB:', paymentRecord);

    // Save to DynamoDB
    try {
      await ddbDocClient.send(new PutCommand({
        TableName: process.env.TABLE_NAME,
        Item: paymentRecord,
      }));
      console.log('Successfully saved payment record to DynamoDB');
    } catch (dbError) {
      console.error('Error saving to DynamoDB:', dbError);
      throw new Error('Failed to save payment record');
    }

    // Prepare email
    console.log('Preparing email with sender:', process.env.SENDER_EMAIL);
    const emailParams = {
      Source: process.env.SENDER_EMAIL,
      Destination: {
        ToAddresses: [customerEmail],
      },
      Message: {
        Subject: {
          Data: 'Game Mixer - Payment Instructions',
        },
        Body: {
          Text: {
            Data: `
Dear ${customerName},

Thank you for your order at Game Mixer. Please follow these steps to complete your payment of $${amount}:

1. Open your Zelle app or banking app with Zelle
2. Send payment to: ${process.env.SENDER_EMAIL}
3. Amount to send: $${amount}
4. Important: Include this Payment ID in the memo: ${paymentId}

Once you've completed the payment, we will verify and process your order.

Order Details:
${JSON.stringify(orderDetails, null, 2)}

Best regards,
Game Mixer Team`,
          },
        },
      },
    };

    // Send email
    try {
      console.log('Sending email via SES:', { to: customerEmail });
      await sesClient.send(new SendEmailCommand(emailParams));
      console.log('Successfully sent email');
    } catch (emailError) {
      console.error('Error sending email:', emailError);
      throw new Error('Failed to send payment instructions email');
    }

    return {
      statusCode: 200,
      headers: {
        'Access-Control-Allow-Origin': '*',
        'Access-Control-Allow-Credentials': true,
      },
      body: JSON.stringify({
        message: 'Payment instructions sent successfully',
        paymentId,
        status: 'PENDING',
      }),
    };
  } catch (error) {
    console.error('Error processing payment:', {
      error: error.message,
      stack: error.stack,
      event: event
    });
    
    return {
      statusCode: 500,
      headers: {
        'Access-Control-Allow-Origin': '*',
        'Access-Control-Allow-Credentials': true,
      },
      body: JSON.stringify({
        message: 'Error processing payment request',
        error: error.message,
      }),
    };
  }
};

// Verify payment status
exports.verifyPayment = async (event) => {
  console.log('Payment verification request received:', {
    body: event.body,
    headers: event.headers
  });

  try {
    const body = JSON.parse(event.body);
    const { paymentId } = body;

    if (!paymentId) {
      console.error('Missing payment ID in verification request');
      return {
        statusCode: 400,
        headers: {
          'Access-Control-Allow-Origin': '*',
          'Access-Control-Allow-Credentials': true,
        },
        body: JSON.stringify({
          message: 'Payment ID is required',
        }),
      };
    }

    console.log('Fetching payment record for ID:', paymentId);
    
    // Get payment record
    const { Item: payment } = await ddbDocClient.send(new GetCommand({
      TableName: process.env.TABLE_NAME,
      Key: { id: paymentId },
    }));

    if (!payment) {
      console.error('Payment record not found for ID:', paymentId);
      return {
        statusCode: 404,
        headers: {
          'Access-Control-Allow-Origin': '*',
          'Access-Control-Allow-Credentials': true,
        },
        body: JSON.stringify({
          message: 'Payment record not found',
        }),
      };
    }

    console.log('Found payment record:', payment);

    // Update payment status
    const updatedPayment = {
      ...payment,
      status: 'COMPLETED',
      completedAt: new Date().toISOString(),
    };

    console.log('Updating payment record:', updatedPayment);

    try {
      await ddbDocClient.send(new PutCommand({
        TableName: process.env.TABLE_NAME,
        Item: updatedPayment,
      }));
      console.log('Successfully updated payment record');
    } catch (dbError) {
      console.error('Error updating payment record:', dbError);
      throw new Error('Failed to update payment status');
    }

    // Send confirmation email
    const emailParams = {
      Source: process.env.SENDER_EMAIL,
      Destination: {
        ToAddresses: [payment.customerEmail],
      },
      Message: {
        Subject: {
          Data: 'Game Mixer - Payment Confirmed',
        },
        Body: {
          Text: {
            Data: `
Dear ${payment.customerName},

We have confirmed your payment of $${payment.amount}. Thank you for your purchase!

Order Details:
${JSON.stringify(payment.orderDetails, null, 2)}

Payment ID: ${paymentId}
Amount: $${payment.amount}
Date: ${updatedPayment.completedAt}

Best regards,
Game Mixer Team`,
          },
        },
      },
    };

    try {
      console.log('Sending confirmation email:', { to: payment.customerEmail });
      await sesClient.send(new SendEmailCommand(emailParams));
      console.log('Successfully sent confirmation email');
    } catch (emailError) {
      console.error('Error sending confirmation email:', emailError);
      throw new Error('Failed to send payment confirmation email');
    }

    return {
      statusCode: 200,
      headers: {
        'Access-Control-Allow-Origin': '*',
        'Access-Control-Allow-Credentials': true,
      },
      body: JSON.stringify({
        message: 'Payment verified successfully',
        payment: updatedPayment,
      }),
    };
  } catch (error) {
    console.error('Error verifying payment:', {
      error: error.message,
      stack: error.stack,
      event: event
    });
    
    return {
      statusCode: 500,
      headers: {
        'Access-Control-Allow-Origin': '*',
        'Access-Control-Allow-Credentials': true,
      },
      body: JSON.stringify({
        message: 'Error verifying payment',
        error: error.message,
      }),
    };
  }
};

================
File: package.json
================
{
  "name": "game-mixer-backend",
  "version": "1.0.0",
  "description": "Game Mixer Backend Services",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "deploy": "serverless deploy"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "dependencies": {
    "@aws-sdk/client-dynamodb": "^3.741.0",
    "@aws-sdk/client-ses": "^3.741.0",
    "@aws-sdk/lib-dynamodb": "^3.741.0",
    "aws-sdk": "^2.1692.0",
    "uuid": "^11.0.5"
  },
  "devDependencies": {
    "esbuild": "^0.24.2",
    "serverless": "^4.6.0",
    "serverless-esbuild": "^1.50.0"
  }
}

================
File: serverless.yml
================
service: game-mixer-backend

frameworkVersion: '3'

custom:
  tableName: ${self:service}-${sls:stage}
  esbuild:
    bundle: true
    minify: true
    sourcemap: true
    exclude: ['aws-sdk']
    target: 'node18'
    platform: 'node'

plugins:
  - serverless-esbuild

provider:
  name: aws
  runtime: nodejs18.x
  stage: ${opt:stage, 'dev'}
  region: ${opt:region, 'us-west-2'}
  environment:
    SENDER_EMAIL: ${env:SENDER_EMAIL}
    TABLE_NAME: ${self:custom.tableName}
  logRetentionInDays: 14
  apiGateway:
    minimumCompressionSize: 1024
    shouldStartNameWithService: true
  iam:
    role:
      statements:
        - Effect: Allow
          Action:
            - dynamodb:PutItem
            - dynamodb:GetItem
            - dynamodb:Query
            - dynamodb:Scan
            - dynamodb:UpdateItem
            - dynamodb:DeleteItem
          Resource: 
            - "arn:aws:dynamodb:${aws:region}:${aws:accountId}:table/${self:provider.environment.TABLE_NAME}"
            - "arn:aws:dynamodb:${aws:region}:${aws:accountId}:table/${self:provider.environment.TABLE_NAME}/index/*"
        - Effect: Allow
          Action:
            - ses:SendEmail
            - ses:SendRawEmail
          Resource: "*"
        - Effect: Allow
          Action:
            - logs:CreateLogGroup
            - logs:CreateLogStream
            - logs:PutLogEvents
          Resource: "*"

package:
  individually: true
  patterns:
    - '!.git/**'
    - '!node_modules/**'
    - '!test/**'
    - '!.env*'
    - '!README.md'
    - '!package-lock.json'
    - '!yarn.lock'

functions:
  handleMonetaryDonation:
    handler: src/handlers/donationHandler.handleMonetaryDonation
    events:
      - http:
          path: donations/monetary
          method: post
          cors:
            origin: '*'
            headers:
              - Content-Type
              - Authorization
              - X-Amz-Date
              - X-Api-Key
              - X-Amz-Security-Token
              - X-Amz-User-Agent
            allowMethods:
              - POST
              - OPTIONS
            allowCredentials: true
    memorySize: 256
    timeout: 30
    reservedConcurrency: 50

  handleGoodsDonation:
    handler: src/handlers/donationHandler.handleGoodsDonation
    events:
      - http:
          path: donations/goods
          method: post
          cors:
            origin: '*'
            headers:
              - Content-Type
              - Authorization
              - X-Amz-Date
              - X-Api-Key
              - X-Amz-Security-Token
              - X-Amz-User-Agent
            allowMethods:
              - POST
              - OPTIONS
            allowCredentials: true
    memorySize: 256
    timeout: 30
    reservedConcurrency: 50

  verifyDonation:
    handler: src/handlers/donationHandler.verifyDonation
    events:
      - http:
          path: donations/verify
          method: post
          cors:
            origin: '*'
            headers:
              - Content-Type
              - Authorization
              - X-Amz-Date
              - X-Api-Key
              - X-Amz-Security-Token
              - X-Amz-User-Agent
            allowMethods:
              - POST
              - OPTIONS
            allowCredentials: true
    memorySize: 256
    timeout: 30

resources:
  Resources:
    DonationsTable:
      Type: AWS::DynamoDB::Table
      Properties:
        TableName: ${self:custom.tableName}
        AttributeDefinitions:
          - AttributeName: id
            AttributeType: S
          - AttributeName: type
            AttributeType: S
          - AttributeName: status
            AttributeType: S
          - AttributeName: contactEmail
            AttributeType: S
          - AttributeName: createdAt
            AttributeType: S
        KeySchema:
          - AttributeName: id
            KeyType: HASH
        GlobalSecondaryIndexes:
          - IndexName: typeIndex
            KeySchema:
              - AttributeName: type
                KeyType: HASH
              - AttributeName: createdAt
                KeyType: RANGE
            Projection:
              ProjectionType: ALL
          - IndexName: statusIndex
            KeySchema:
              - AttributeName: status
                KeyType: HASH
              - AttributeName: createdAt
                KeyType: RANGE
            Projection:
              ProjectionType: ALL
          - IndexName: emailIndex
            KeySchema:
              - AttributeName: contactEmail
                KeyType: HASH
              - AttributeName: createdAt
                KeyType: RANGE
            Projection:
              ProjectionType: ALL
        BillingMode: PAY_PER_REQUEST
        TimeToLiveSpecification:
          AttributeName: ttl
          Enabled: true
        Tags:
          - Key: Environment
            Value: ${self:provider.stage}

    GatewayResponseDefault4XX:
      Type: 'AWS::ApiGateway::GatewayResponse'
      Properties:
        ResponseParameters:
          gatewayresponse.header.Access-Control-Allow-Origin: "'*'"
          gatewayresponse.header.Access-Control-Allow-Headers: "'*'"
        ResponseType: DEFAULT_4XX
        RestApiId:
          Ref: 'ApiGatewayRestApi'

    GatewayResponseDefault5XX:
      Type: 'AWS::ApiGateway::GatewayResponse'
      Properties:
        ResponseParameters:
          gatewayresponse.header.Access-Control-Allow-Origin: "'*'"
          gatewayresponse.header.Access-Control-Allow-Headers: "'*'"
        ResponseType: DEFAULT_5XX
        RestApiId:
          Ref: 'ApiGatewayRestApi'
